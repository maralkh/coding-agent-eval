{
  "id": "scikit-learn__scikit-learn-30557",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "8fd043f0eaae964da79bb19f9d3c6f2534cf85c0",
  "issue_number": 1234,
  "issue_title": "MRG fix bincount mess I made in kmeans.",
  "issue_body": "This should clean up the stuff I pushed earlier.\ncc @ogrisel @gaelvaroquaux Could you have a brief look? What I pushed earlier is buggy but I didn't dare push again after so many failed fixes.\n",
  "pr_number": 30557,
  "pr_title": "FIX Uses log2 in tree building",
  "gold_patch": "diff --git a/doc/whats_new/upcoming_changes/sklearn.tree/30557.fix.rst b/doc/whats_new/upcoming_changes/sklearn.tree/30557.fix.rst\nnew file mode 100644\nindex 0000000000000..86ba5c9a88e9d\n--- /dev/null\n+++ b/doc/whats_new/upcoming_changes/sklearn.tree/30557.fix.rst\n@@ -0,0 +1,2 @@\n+- Use `log2` instead of `ln` for building trees to maintain behavior of previous\n+  versions. By `Thomas Fan`_\ndiff --git a/sklearn/tree/_partitioner.pyx b/sklearn/tree/_partitioner.pyx\nindex 195b7e2caf67c..575a9413e09ca 100644\n--- a/sklearn/tree/_partitioner.pyx\n+++ b/sklearn/tree/_partitioner.pyx\n@@ -11,7 +11,7 @@ and sparse data stored in a Compressed Sparse Column (CSC) format.\n # SPDX-License-Identifier: BSD-3-Clause\n \n from cython cimport final\n-from libc.math cimport isnan, log\n+from libc.math cimport isnan, log2\n from libc.stdlib cimport qsort\n from libc.string cimport memcpy\n \n@@ -503,8 +503,8 @@ cdef class SparsePartitioner:\n         # O(n_samples * log(n_indices)) is the running time of binary\n         # search and O(n_indices) is the running time of index_to_samples\n         # approach.\n-        if ((1 - self.is_samples_sorted) * n_samples * log(n_samples) +\n-                n_samples * log(n_indices) < EXTRACT_NNZ_SWITCH * n_indices):\n+        if ((1 - self.is_samples_sorted) * n_samples * log2(n_samples) +\n+                n_samples * log2(n_indices) < EXTRACT_NNZ_SWITCH * n_indices):\n             extract_nnz_binary_search(X_indices, X_data,\n                                       indptr_start, indptr_end,\n                                       samples, self.start, self.end,\n@@ -702,12 +702,17 @@ cdef inline void shift_missing_values_to_left_if_required(\n         best.pos += best.n_missing\n \n \n+def _py_sort(float32_t[::1] feature_values, intp_t[::1] samples, intp_t n):\n+    \"\"\"Used for testing sort.\"\"\"\n+    sort(&feature_values[0], &samples[0], n)\n+\n+\n # Sort n-element arrays pointed to by feature_values and samples, simultaneously,\n # by the values in feature_values. Algorithm: Introsort (Musser, SP&E, 1997).\n cdef inline void sort(float32_t* feature_values, intp_t* samples, intp_t n) noexcept nogil:\n     if n == 0:\n         return\n-    cdef intp_t maxd = 2 * <intp_t>log(n)\n+    cdef intp_t maxd = 2 * <intp_t>log2(n)\n     introsort(feature_values, samples, n, maxd)\n \n \ndiff --git a/sklearn/tree/tests/test_tree.py b/sklearn/tree/tests/test_tree.py\nindex cb13cf83cc782..dc36bd6dc6a3e 100644\n--- a/sklearn/tree/tests/test_tree.py\n+++ b/sklearn/tree/tests/test_tree.py\n@@ -36,6 +36,7 @@\n     DENSE_SPLITTERS,\n     SPARSE_SPLITTERS,\n )\n+from sklearn.tree._partitioner import _py_sort\n from sklearn.tree._tree import (\n     NODE_DTYPE,\n     TREE_LEAF,\n@@ -2814,3 +2815,25 @@ def test_build_pruned_tree_infinite_loop():\n         ValueError, match=\"Node has reached a leaf in the original tree\"\n     ):\n         _build_pruned_tree_py(pruned_tree, tree.tree_, leave_in_subtree)\n+\n+\n+def test_sort_log2_build():\n+    \"\"\"Non-regression test for gh-30554.\n+\n+    Using log2 and log in sort correctly sorts feature_values, but the tie breaking is\n+    different which can results in placing samples in a different order.\n+    \"\"\"\n+    rng = np.random.default_rng(75)\n+    some = rng.normal(loc=0.0, scale=10.0, size=10).astype(np.float32)\n+    feature_values = np.concatenate([some] * 5)\n+    samples = np.arange(50)\n+    _py_sort(feature_values, samples, 50)\n+    # fmt: off\n+    # no black reformatting for this specific array\n+    expected_samples = [\n+        0, 40, 30, 20, 10, 29, 39, 19, 49,  9, 45, 15, 35,  5, 25, 11, 31,\n+        41,  1, 21, 22, 12,  2, 42, 32, 23, 13, 43,  3, 33,  6, 36, 46, 16,\n+        26,  4, 14, 24, 34, 44, 27, 47,  7, 37, 17,  8, 38, 48, 28, 18\n+    ]\n+    # fmt: on\n+    assert_array_equal(samples, expected_samples)\n",
  "fail_to_pass": [
    "test_sort_log2_build"
  ],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/tree/tests/test_tree.py"
  ],
  "difficulty": "medium",
  "created_at": "2024-12-30T04:59:42Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/30557",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/pull/1234"
}