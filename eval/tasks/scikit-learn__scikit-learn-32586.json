{
  "id": "scikit-learn__scikit-learn-32586",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "72d97bceec1af70d9b65bb49d12abdd5694e67f1",
  "issue_number": 26024,
  "issue_title": "Make more of the \"tools\" of scikit-learn Array API compatible",
  "issue_body": "\ud83d\udea8 \ud83d\udea7 This issue requires a bit of patience and experience to contribute to \ud83d\udea7 \ud83d\udea8 \r\n\r\n- Original issue introducing array API in scikit-learn: #22352\r\n- array API official doc/spec: https://data-apis.org/array-api/\r\n- scikit-learn doc: https://scikit-learn.org/dev/modules/array_api.html\r\n\r\nPlease mention this issue when you create a PR, but please don't write \"closes #26024\" or \"fixes #26024\".\r\n\r\nscikit-learn contains lots of useful tools, in addition to the many estimators it has. For example [metrics](https://scikit-learn.org/stable/modules/classes.html#sklearn-metrics-metrics), [pipelines](https://scikit-learn.org/stable/modules/classes.html#module-sklearn.pipeline), [pre-processing](https://scikit-learn.org/stable/modules/classes.html#module-sklearn.preprocessing) and [mode selection](https://scikit-learn.org/stable/modules/classes.html#module-sklearn.model_selection). These are useful to and used by people who do not necessarily use an estimator from scikit-learn. This is great.\r\n\r\nThe fact that many users install scikit-learn \"just\" to use `train_test_split` is a testament to how useful it is to provide easy to use tools that do the right(!) thing. Instead of everyone implementing them from scratch because it is \"easy\" and making mistakes along the way.\r\n\r\nIn this issue I'd like to collect and track work related to making it easier to use all these \"tools\" from scikit-learn even if you are not using Numpy arrays for your data. In particular thanks to the Array API standard it should be \"not too much work\" to make things usable with data that is in an array that conforms to the Array API standard.\r\n\r\nThere is work in #25956 and #22554 which adds the basic infrastructure needed to use \"array API arrays\".\r\n\r\nThe goal of this issue is to make code like the following work:\r\n```python\r\n>>> from sklearn.preprocessing import MinMaxScaler\r\n>>> from sklearn import config_context\r\n>>> from sklearn.datasets import make_classification\r\n>>> import torch\r\n>>> X_np, y_np = make_classification(random_state=0)\r\n>>> X_torch = torch.asarray(X_np, device=\"cuda\", dtype=torch.float32)\r\n>>> y_torch = torch.asarray(y_np, device=\"cuda\", dtype=torch.float32)\r\n\r\n>>> with config_context(array_api_dispatch=True):\r\n...     # For example using MinMaxScaler on PyTorch tensors\r\n...     scale = MinMaxScaler()\r\n...     X_trans = scale.fit_transform(X_torch, y_torch)\r\n...     assert type(X_trans) == type(X_torch)\r\n...     assert X_trans.device == X_torch.device\r\n```\r\n\r\nThe first step (or maybe part of the first) is to check which of them already \"just work\". After that is done we can start the work (one PR per class/function) making changes.\r\n\r\n\r\n## Guidelines for testing\r\n\r\nGeneral comment: most of the time when we add array API support to a function in scikit-learn, we do not touch the existing (numpy-only) tests to make sure that the PR does not change the default behavior of scikit-learn on traditional inputs when array API is not enabled.\r\n\r\nIn the case of an estimator, it can be enough to add the `array_api_support=True` estimator tag in a method named `__sklearn_tags__`. For metric functions, just register it in the `array_api_metric_checkers` in `sklearn/metrics/tests/test_common.py` to include it in the common test.\r\n\r\nFor other kinds of functions not covered by existing common tests, or when the array API support depends heavily on non-default values, it might be required to add one or more new test functions to the related module-level test file. The general testing scheme is the following:\r\n\r\n- generate some random test data with numpy or `sklearn.datasets.make_*`;\r\n- call the function once on the numpy inputs without enabling array API dispatch;\r\n- convert the inputs to a namespace / device combo passed as parameter to the test;\r\n- call the function with array API dispatching enabled (under a `with sklearn.config_context(array_api_dispatch=True)` block\r\n- check that the results are on the same namespace and device as the input\r\n- convert back the output to a numpy array using `_convert_to_numpy`\r\n- compare the original / reference numpy results and the `xp` computation results converted back to numpy using `assert_allclose` or similar.\r\n\r\nThose tests should have `array_api` somewhere in their name to makes sure that we can run all the array API compliance tests with a keyword search in the pytest command line, e.g.:\r\n\r\n```\r\npytest -k array_api sklearn/some/subpackage\r\n```\r\n\r\nIn particular, for cost reasons, our CUDA GPU CI only runs `pytest -k array_api sklearn`. So it's very important to respect this naming conventions, otherwise we will not tests all what we are supposed to test on CUDA.\r\n\r\nMore generally, look at merged array API pull requests to see how testing is typically handled.",
  "pr_number": 32586,
  "pr_title": "Add array API support to `det_curve`",
  "gold_patch": "diff --git a/doc/modules/array_api.rst b/doc/modules/array_api.rst\nindex e263ef51d5723..2b7be6d146cbb 100644\n--- a/doc/modules/array_api.rst\n+++ b/doc/modules/array_api.rst\n@@ -151,6 +151,7 @@ Metrics\n - :func:`sklearn.metrics.d2_brier_score`\n - :func:`sklearn.metrics.d2_log_loss_score`\n - :func:`sklearn.metrics.d2_tweedie_score`\n+- :func:`sklearn.metrics.det_curve`\n - :func:`sklearn.metrics.explained_variance_score`\n - :func:`sklearn.metrics.f1_score`\n - :func:`sklearn.metrics.fbeta_score`\ndiff --git a/doc/whats_new/upcoming_changes/array-api/32586.feature.rst b/doc/whats_new/upcoming_changes/array-api/32586.feature.rst\nnew file mode 100644\nindex 0000000000000..8770a2422140b\n--- /dev/null\n+++ b/doc/whats_new/upcoming_changes/array-api/32586.feature.rst\n@@ -0,0 +1,2 @@\n+- :func:`sklearn.metrics.det_curve` now supports Array API compliant inputs.\n+  By :user:`Josef Affourtit <jaffourt>`.\ndiff --git a/sklearn/metrics/_ranking.py b/sklearn/metrics/_ranking.py\nindex 9ed5169e5b888..cf2ab70c89a5b 100644\n--- a/sklearn/metrics/_ranking.py\n+++ b/sklearn/metrics/_ranking.py\n@@ -372,15 +372,18 @@ def det_curve(\n     >>> thresholds\n     array([0.35, 0.4 , 0.8 ])\n     \"\"\"\n+\n+    xp, _, device = get_namespace_and_device(y_true, y_score)\n     fps, tps, thresholds = _binary_clf_curve(\n         y_true, y_score, pos_label=pos_label, sample_weight=sample_weight\n     )\n \n     # add a threshold at inf where the clf always predicts the negative class\n     # i.e. tps = fps = 0\n-    tps = np.concatenate(([0], tps))\n-    fps = np.concatenate(([0], fps))\n-    thresholds = np.concatenate(([np.inf], thresholds))\n+    tps = xp.concat((xp.asarray([0.0], device=device), tps))\n+    fps = xp.concat((xp.asarray([0.0], device=device), fps))\n+    thresholds = xp.astype(thresholds, _max_precision_float_dtype(xp, device))\n+    thresholds = xp.concat((xp.asarray([xp.inf], device=device), thresholds))\n \n     if drop_intermediate and len(fps) > 2:\n         # Drop thresholds where true positives (tp) do not change from the\n@@ -389,16 +392,20 @@ def det_curve(\n         # false positive rate (fpr) changes, producing horizontal line segments\n         # in the transformed (normal deviate) scale. These intermediate points\n         # can be dropped to create lighter DET curve plots.\n-        optimal_idxs = np.where(\n-            np.concatenate(\n-                [[True], np.logical_or(np.diff(tps[:-1]), np.diff(tps[1:])), [True]]\n+        optimal_idxs = xp.where(\n+            xp.concat(\n+                [\n+                    xp.asarray([True], device=device),\n+                    xp.logical_or(xp.diff(tps[:-1]), xp.diff(tps[1:])),\n+                    xp.asarray([True], device=device),\n+                ]\n             )\n         )[0]\n         fps = fps[optimal_idxs]\n         tps = tps[optimal_idxs]\n         thresholds = thresholds[optimal_idxs]\n \n-    if len(np.unique(y_true)) != 2:\n+    if xp.unique_values(y_true).shape[0] != 2:\n         raise ValueError(\n             \"Only one class is present in y_true. Detection error \"\n             \"tradeoff curve is not defined in that case.\"\n@@ -410,16 +417,20 @@ def det_curve(\n \n     # start with false positives zero, which may be at a finite threshold\n     first_ind = (\n-        fps.searchsorted(fps[0], side=\"right\") - 1\n-        if fps.searchsorted(fps[0], side=\"right\") > 0\n+        xp.searchsorted(fps, fps[0], side=\"right\") - 1\n+        if xp.searchsorted(fps, fps[0], side=\"right\") > 0\n         else None\n     )\n     # stop with false negatives zero\n-    last_ind = tps.searchsorted(tps[-1]) + 1\n+    last_ind = xp.searchsorted(tps, tps[-1]) + 1\n     sl = slice(first_ind, last_ind)\n \n     # reverse the output such that list of false positives is decreasing\n-    return (fps[sl][::-1] / n_count, fns[sl][::-1] / p_count, thresholds[sl][::-1])\n+    return (\n+        xp.flip(fps[sl]) / n_count,\n+        xp.flip(fns[sl]) / p_count,\n+        xp.flip(thresholds[sl]),\n+    )\n \n \n def _binary_roc_auc_score(y_true, y_score, sample_weight=None, max_fpr=None):\ndiff --git a/sklearn/metrics/tests/test_common.py b/sklearn/metrics/tests/test_common.py\nindex 7b91d6016dceb..eebe4213158c8 100644\n--- a/sklearn/metrics/tests/test_common.py\n+++ b/sklearn/metrics/tests/test_common.py\n@@ -2252,6 +2252,7 @@ def check_array_api_metric_pairwise(metric, array_namespace, device, dtype_name)\n         check_array_api_binary_classification_metric,\n         check_array_api_multiclass_classification_metric,\n     ],\n+    det_curve: [check_array_api_binary_classification_metric],\n     f1_score: [\n         check_array_api_binary_classification_metric,\n         check_array_api_multiclass_classification_metric,\n",
  "fail_to_pass": [],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/metrics/_ranking.py",
    "sklearn/metrics/tests/test_common.py"
  ],
  "difficulty": "hard",
  "created_at": "2025-10-27T17:48:47Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/32586",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/issues/26024"
}