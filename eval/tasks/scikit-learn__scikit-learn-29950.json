{
  "id": "scikit-learn__scikit-learn-29950",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "b9a74964c3d2b67b83392d267462d498b31dcfab",
  "issue_number": 29827,
  "issue_title": "SimpleImputer does not drop a column full of `np.nan` even when `keep_empty_feature=False`",
  "issue_body": "The following code snippet lead to some surprises:\r\n\r\n```python\r\nimport numpy as np\r\nfrom sklearn.datasets import load_iris\r\nfrom sklearn.impute import SimpleImputer\r\n\r\nX, y = load_iris(return_X_y=True)\r\nX[:, 0] = np.nan\r\n\r\nimputer = SimpleImputer(keep_empty_features=False, strategy=\"constant\", fill_value=1)\r\nX_trans = imputer.fit_transform(X)\r\n\r\nassert X_trans.shape[1] == 3, f\"X_trans contains {X.shape[1]} columns\"\r\n```\r\n\r\n```pytb\r\n---------------------------------------------------------------------------\r\nAssertionError                            Traceback (most recent call last)\r\nCell In[19], line 11\r\n      8 imputer = SimpleImputer(keep_empty_features=False, strategy=\"constant\", fill_value=1)\r\n      9 X_trans = imputer.fit_transform(X)\r\n---> 11 assert X_trans.shape[1] == 3, f\"X_trans contains {X.shape[1]} columns\"\r\n\r\nAssertionError: X_trans contains 4 columns\r\n```\r\n\r\nApparently this is something that we really wanted for backward compatibility when merging https://github.com/scikit-learn/scikit-learn/issues/24770:\r\n\r\nhttps://github.com/scikit-learn/scikit-learn/blob/c91528c4c2efecc344622e3435157ba3b39a7253/sklearn/impute/tests/test_impute.py#L1670-L1692\r\n\r\nNow, I'm wondering if we should not deprecate this behaviour since the parameter `keep_empty_feature` allows to control whether or not we should drop the feature entirely.\r\n\r\nSo I would propose to warn for a change of behaviour when `strategy=\"constant\"`, `keep_empty_feature=False`, and that we detect that we have empty feature(s).",
  "pr_number": 29950,
  "pr_title": "DEP Adding a warning in the SimpleImputer when strategy mode is constant and keep_empty_features is False",
  "gold_patch": "diff --git a/doc/whats_new/upcoming_changes/sklearn.impute/29950.api.rst b/doc/whats_new/upcoming_changes/sklearn.impute/29950.api.rst\nnew file mode 100644\nindex 0000000000000..27ac9e06ac320\n--- /dev/null\n+++ b/doc/whats_new/upcoming_changes/sklearn.impute/29950.api.rst\n@@ -0,0 +1,4 @@\n+- Add a warning in :class:`impute.SimpleImputer` when `keep_empty_feature=False` and\n+  `strategy=\"constant\"`. In this case empty features are not dropped and this behaviour\n+  will change in 1.8.\n+  By :user:`Arthur Courselle <ArthurCourselle>` and :user:`Simon Riou <simon-riou>`\n\\ No newline at end of file\ndiff --git a/sklearn/impute/_base.py b/sklearn/impute/_base.py\nindex aecc235ecd6ac..faf1f9e23b678 100644\n--- a/sklearn/impute/_base.py\n+++ b/sklearn/impute/_base.py\n@@ -225,6 +225,11 @@ class SimpleImputer(_BaseImputer):\n \n         .. versionadded:: 1.2\n \n+        .. versionchanged:: 1.6\n+            Currently, when `keep_empty_feature=False` and `strategy=\"constant\"`,\n+            empty features are not dropped. This behaviour will change in version\n+            1.8. Set `keep_empty_feature=True` to preserve this behaviour.\n+\n     Attributes\n     ----------\n     statistics_ : array of shape (n_features,)\n@@ -458,6 +463,19 @@ def _sparse_fit(self, X, strategy, missing_values, fill_value):\n         statistics = np.empty(X.shape[1])\n \n         if strategy == \"constant\":\n+            # TODO(1.8): Remove FutureWarning and add `np.nan` as a statistic\n+            # for empty features to drop them later.\n+            if not self.keep_empty_features and any(\n+                [all(missing_mask[:, i].data) for i in range(missing_mask.shape[1])]\n+            ):\n+                warnings.warn(\n+                    \"Currently, when `keep_empty_feature=False` and \"\n+                    '`strategy=\"constant\"`, empty features are not dropped. '\n+                    \"This behaviour will change in version 1.8. Set \"\n+                    \"`keep_empty_feature=True` to preserve this behaviour.\",\n+                    FutureWarning,\n+                )\n+\n             # for constant strategy, self.statistics_ is used to store\n             # fill_value in each column\n             statistics.fill(fill_value)\n@@ -548,6 +566,17 @@ def _dense_fit(self, X, strategy, missing_values, fill_value):\n \n         # Constant\n         elif strategy == \"constant\":\n+            # TODO(1.8): Remove FutureWarning and add `np.nan` as a statistic\n+            # for empty features to drop them later.\n+            if not self.keep_empty_features and ma.getmask(masked_X).all(axis=0).any():\n+                warnings.warn(\n+                    \"Currently, when `keep_empty_feature=False` and \"\n+                    '`strategy=\"constant\"`, empty features are not dropped. '\n+                    \"This behaviour will change in version 1.8. Set \"\n+                    \"`keep_empty_feature=True` to preserve this behaviour.\",\n+                    FutureWarning,\n+                )\n+\n             # for constant strategy, self.statistcs_ is used to store\n             # fill_value in each column\n             return np.full(X.shape[1], fill_value, dtype=X.dtype)\ndiff --git a/sklearn/impute/_iterative.py b/sklearn/impute/_iterative.py\nindex a471ca9313add..86723c8245d44 100644\n--- a/sklearn/impute/_iterative.py\n+++ b/sklearn/impute/_iterative.py\n@@ -636,6 +636,13 @@ def _initial_imputation(self, X, in_fit=False):\n \n         X_missing_mask = _get_mask(X, self.missing_values)\n         mask_missing_values = X_missing_mask.copy()\n+\n+        # TODO (1.8): remove this once the deprecation is removed. In the meantime,\n+        # we need to catch the warning to avoid false positives.\n+        catch_warning = (\n+            self.initial_strategy == \"constant\" and not self.keep_empty_features\n+        )\n+\n         if self.initial_imputer_ is None:\n             self.initial_imputer_ = SimpleImputer(\n                 missing_values=self.missing_values,\n@@ -643,9 +650,24 @@ def _initial_imputation(self, X, in_fit=False):\n                 fill_value=self.fill_value,\n                 keep_empty_features=self.keep_empty_features,\n             ).set_output(transform=\"default\")\n-            X_filled = self.initial_imputer_.fit_transform(X)\n+\n+            # TODO (1.8): remove this once the deprecation is removed to keep only\n+            # the code in the else case.\n+            if catch_warning:\n+                with warnings.catch_warnings():\n+                    warnings.simplefilter(\"ignore\", FutureWarning)\n+                    X_filled = self.initial_imputer_.fit_transform(X)\n+            else:\n+                X_filled = self.initial_imputer_.fit_transform(X)\n         else:\n-            X_filled = self.initial_imputer_.transform(X)\n+            # TODO (1.8): remove this once the deprecation is removed to keep only\n+            # the code in the else case.\n+            if catch_warning:\n+                with warnings.catch_warnings():\n+                    warnings.simplefilter(\"ignore\", FutureWarning)\n+                    X_filled = self.initial_imputer_.transform(X)\n+            else:\n+                X_filled = self.initial_imputer_.transform(X)\n \n         if in_fit:\n             self._is_empty_feature = np.all(mask_missing_values, axis=0)\n@@ -659,7 +681,8 @@ def _initial_imputation(self, X, in_fit=False):\n                 # The constant strategy has a specific behavior and preserve empty\n                 # features even with ``keep_empty_features=False``. We need to drop\n                 # the column for consistency.\n-                # TODO: remove this `if` branch once the following issue is addressed:\n+                # TODO (1.8): remove this `if` branch once the following issue is\n+                # addressed:\n                 # https://github.com/scikit-learn/scikit-learn/issues/29827\n                 X_filled = X_filled[:, ~self._is_empty_feature]\n \ndiff --git a/sklearn/impute/tests/test_impute.py b/sklearn/impute/tests/test_impute.py\nindex df8715327163d..b92e8ecd8f01f 100644\n--- a/sklearn/impute/tests/test_impute.py\n+++ b/sklearn/impute/tests/test_impute.py\n@@ -410,18 +410,24 @@ def test_imputation_constant_error_invalid_type(X_data, missing_value):\n         imputer.fit_transform(X)\n \n \n+# TODO (1.8): check that `keep_empty_features=False` drop the\n+# empty features due to the behaviour change.\n def test_imputation_constant_integer():\n     # Test imputation using the constant strategy on integers\n     X = np.array([[-1, 2, 3, -1], [4, -1, 5, -1], [6, 7, -1, -1], [8, 9, 0, -1]])\n \n     X_true = np.array([[0, 2, 3, 0], [4, 0, 5, 0], [6, 7, 0, 0], [8, 9, 0, 0]])\n \n-    imputer = SimpleImputer(missing_values=-1, strategy=\"constant\", fill_value=0)\n+    imputer = SimpleImputer(\n+        missing_values=-1, strategy=\"constant\", fill_value=0, keep_empty_features=True\n+    )\n     X_trans = imputer.fit_transform(X)\n \n     assert_array_equal(X_trans, X_true)\n \n \n+# TODO (1.8): check that `keep_empty_features=False` drop the\n+# empty features due to the behaviour change.\n @pytest.mark.parametrize(\"array_constructor\", CSR_CONTAINERS + [np.asarray])\n def test_imputation_constant_float(array_constructor):\n     # Test imputation using the constant strategy on floats\n@@ -442,12 +448,16 @@ def test_imputation_constant_float(array_constructor):\n \n     X_true = array_constructor(X_true)\n \n-    imputer = SimpleImputer(strategy=\"constant\", fill_value=-1)\n+    imputer = SimpleImputer(\n+        strategy=\"constant\", fill_value=-1, keep_empty_features=True\n+    )\n     X_trans = imputer.fit_transform(X)\n \n     assert_allclose_dense_sparse(X_trans, X_true)\n \n \n+# TODO (1.8): check that `keep_empty_features=False` drop the\n+# empty features due to the behaviour change.\n @pytest.mark.parametrize(\"marker\", [None, np.nan, \"NAN\", \"\", 0])\n def test_imputation_constant_object(marker):\n     # Test imputation using the constant strategy on objects\n@@ -472,13 +482,18 @@ def test_imputation_constant_object(marker):\n     )\n \n     imputer = SimpleImputer(\n-        missing_values=marker, strategy=\"constant\", fill_value=\"missing\"\n+        missing_values=marker,\n+        strategy=\"constant\",\n+        fill_value=\"missing\",\n+        keep_empty_features=True,\n     )\n     X_trans = imputer.fit_transform(X)\n \n     assert_array_equal(X_trans, X_true)\n \n \n+# TODO (1.8): check that `keep_empty_features=False` drop the\n+# empty features due to the behaviour change.\n @pytest.mark.parametrize(\"dtype\", [object, \"category\"])\n def test_imputation_constant_pandas(dtype):\n     # Test imputation using the constant strategy on pandas df\n@@ -498,7 +513,7 @@ def test_imputation_constant_pandas(dtype):\n         dtype=object,\n     )\n \n-    imputer = SimpleImputer(strategy=\"constant\")\n+    imputer = SimpleImputer(strategy=\"constant\", keep_empty_features=True)\n     X_trans = imputer.fit_transform(df)\n \n     assert_array_equal(X_trans, X_true)\n@@ -1514,6 +1529,26 @@ def test_most_frequent(expected, array, dtype, extra_value, n_repeat):\n     )\n \n \n+@pytest.mark.parametrize(\n+    \"initial_strategy\", [\"mean\", \"median\", \"most_frequent\", \"constant\"]\n+)\n+def test_iterative_imputer_keep_empty_features(initial_strategy):\n+    \"\"\"Check the behaviour of the iterative imputer with different initial strategy\n+    and keeping empty features (i.e. features containing only missing values).\n+    \"\"\"\n+    X = np.array([[1, np.nan, 2], [3, np.nan, np.nan]])\n+\n+    imputer = IterativeImputer(\n+        initial_strategy=initial_strategy, keep_empty_features=True\n+    )\n+    X_imputed = imputer.fit_transform(X)\n+    assert_allclose(X_imputed[:, 1], 0)\n+    X_imputed = imputer.transform(X)\n+    assert_allclose(X_imputed[:, 1], 0)\n+\n+\n+# TODO (1.8): check that `keep_empty_features=False` drop the\n+# empty features due to the behaviour change.\n def test_iterative_imputer_constant_fill_value():\n     \"\"\"Check that we propagate properly the parameter `fill_value`.\"\"\"\n     X = np.array([[-1, 2, 3, -1], [4, -1, 5, -1], [6, 7, -1, -1], [8, 9, 0, -1]])\n@@ -1524,6 +1559,7 @@ def test_iterative_imputer_constant_fill_value():\n         initial_strategy=\"constant\",\n         fill_value=fill_value,\n         max_iter=0,\n+        keep_empty_features=True,\n     )\n     imputer.fit_transform(X)\n     assert_array_equal(imputer.initial_imputer_.statistics_, fill_value)\n@@ -1722,7 +1758,13 @@ def test_simple_imputer_constant_keep_empty_features(array_type, keep_empty_feat\n     )\n \n     for method in [\"fit_transform\", \"transform\"]:\n-        X_imputed = getattr(imputer, method)(X)\n+        # TODO(1.8): Remove the condition and still call getattr(imputer, method)(X)\n+        if method.startswith(\"fit\") and not keep_empty_features:\n+            warn_msg = '`strategy=\"constant\"`, empty features are not dropped. '\n+            with pytest.warns(FutureWarning, match=warn_msg):\n+                X_imputed = getattr(imputer, method)(X)\n+        else:\n+            X_imputed = getattr(imputer, method)(X)\n         assert X_imputed.shape == X.shape\n         constant_feature = (\n             X_imputed[:, 0].toarray() if array_type == \"sparse\" else X_imputed[:, 0]\n",
  "fail_to_pass": [
    "test_iterative_imputer_keep_empty_features"
  ],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/impute/_base.py",
    "sklearn/impute/_iterative.py",
    "sklearn/impute/tests/test_impute.py"
  ],
  "difficulty": "hard",
  "created_at": "2024-09-27T15:06:39Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/29950",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/issues/29827"
}