{
  "id": "scikit-learn__scikit-learn-30128",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "6bf2061f76ba0977c1f7ffb9ddc48db794e5c7ec",
  "issue_number": 1234,
  "issue_title": "MRG fix bincount mess I made in kmeans.",
  "issue_body": "This should clean up the stuff I pushed earlier.\ncc @ogrisel @gaelvaroquaux Could you have a brief look? What I pushed earlier is buggy but I didn't dare push again after so many failed fixes.\n",
  "pr_number": 30128,
  "pr_title": "ENH Reduce redundancy in floating type checks for Array API support in `_regression.py`",
  "gold_patch": "diff --git a/sklearn/metrics/_regression.py b/sklearn/metrics/_regression.py\nindex 62251f9b96188..c5ebe67e34a2e 100644\n--- a/sklearn/metrics/_regression.py\n+++ b/sklearn/metrics/_regression.py\n@@ -58,11 +58,16 @@\n def _check_reg_targets(y_true, y_pred, multioutput, dtype=\"numeric\", xp=None):\n     \"\"\"Check that y_true and y_pred belong to the same regression task.\n \n+    To reduce redundancy when calling `_find_matching_floating_dtype`,\n+    please use `_check_reg_targets_with_floating_dtype` instead.\n+\n     Parameters\n     ----------\n-    y_true : array-like\n+    y_true : array-like of shape (n_samples,) or (n_samples, n_outputs)\n+        Ground truth (correct) target values.\n \n-    y_pred : array-like\n+    y_pred : array-like of shape (n_samples,) or (n_samples, n_outputs)\n+        Estimated target values.\n \n     multioutput : array-like or string in ['raw_values', uniform_average',\n         'variance_weighted'] or None\n@@ -137,6 +142,71 @@ def _check_reg_targets(y_true, y_pred, multioutput, dtype=\"numeric\", xp=None):\n     return y_type, y_true, y_pred, multioutput\n \n \n+def _check_reg_targets_with_floating_dtype(\n+    y_true, y_pred, sample_weight, multioutput, xp=None\n+):\n+    \"\"\"Ensures that y_true, y_pred, and sample_weight correspond to the same\n+    regression task.\n+\n+    Extends `_check_reg_targets` by automatically selecting a suitable floating-point\n+    data type for inputs using `_find_matching_floating_dtype`.\n+\n+    Use this private method only when converting inputs to array API-compatibles.\n+\n+    Parameters\n+    ----------\n+    y_true : array-like of shape (n_samples,) or (n_samples, n_outputs)\n+        Ground truth (correct) target values.\n+\n+    y_pred : array-like of shape (n_samples,) or (n_samples, n_outputs)\n+        Estimated target values.\n+\n+    sample_weight : array-like of shape (n_samples,)\n+\n+    multioutput : array-like or string in ['raw_values', 'uniform_average', \\\n+        'variance_weighted'] or None\n+        None is accepted due to backward compatibility of r2_score().\n+\n+    xp : module, default=None\n+        Precomputed array namespace module. When passed, typically from a caller\n+        that has already performed inspection of its own inputs, skips array\n+        namespace inspection.\n+\n+    Returns\n+    -------\n+    type_true : one of {'continuous', 'continuous-multioutput'}\n+        The type of the true target data, as output by\n+        'utils.multiclass.type_of_target'.\n+\n+    y_true : array-like of shape (n_samples, n_outputs)\n+        Ground truth (correct) target values.\n+\n+    y_pred : array-like of shape (n_samples, n_outputs)\n+        Estimated target values.\n+\n+    sample_weight : array-like of shape (n_samples,), default=None\n+        Sample weights.\n+\n+    multioutput : array-like of shape (n_outputs) or string in ['raw_values', \\\n+        'uniform_average', 'variance_weighted'] or None\n+        Custom output weights if ``multioutput`` is array-like or\n+        just the corresponding argument if ``multioutput`` is a\n+        correct keyword.\n+    \"\"\"\n+    dtype_name = _find_matching_floating_dtype(y_true, y_pred, sample_weight, xp=xp)\n+\n+    y_type, y_true, y_pred, multioutput = _check_reg_targets(\n+        y_true, y_pred, multioutput, dtype=dtype_name, xp=xp\n+    )\n+\n+    # _check_reg_targets does not accept sample_weight as input.\n+    # Convert sample_weight's data type separately to match dtype_name.\n+    if sample_weight is not None:\n+        sample_weight = xp.asarray(sample_weight, dtype=dtype_name)\n+\n+    return y_type, y_true, y_pred, sample_weight, multioutput\n+\n+\n @validate_params(\n     {\n         \"y_true\": [\"array-like\"],\n@@ -201,14 +271,14 @@ def mean_absolute_error(\n     >>> mean_absolute_error(y_true, y_pred, multioutput=[0.3, 0.7])\n     0.85...\n     \"\"\"\n-    input_arrays = [y_true, y_pred, sample_weight, multioutput]\n-    xp, _ = get_namespace(*input_arrays)\n-\n-    dtype = _find_matching_floating_dtype(y_true, y_pred, sample_weight, xp=xp)\n+    xp, _ = get_namespace(y_true, y_pred, sample_weight, multioutput)\n \n-    _, y_true, y_pred, multioutput = _check_reg_targets(\n-        y_true, y_pred, multioutput, dtype=dtype, xp=xp\n+    _, y_true, y_pred, sample_weight, multioutput = (\n+        _check_reg_targets_with_floating_dtype(\n+            y_true, y_pred, sample_weight, multioutput, xp=xp\n+        )\n     )\n+\n     check_consistent_length(y_true, y_pred, sample_weight)\n \n     output_errors = _average(\n@@ -398,19 +468,16 @@ def mean_absolute_percentage_error(\n     >>> mean_absolute_percentage_error(y_true, y_pred)\n     112589990684262.48\n     \"\"\"\n-    input_arrays = [y_true, y_pred, sample_weight, multioutput]\n-    xp, _ = get_namespace(*input_arrays)\n-    dtype = _find_matching_floating_dtype(y_true, y_pred, sample_weight, xp=xp)\n-\n-    y_type, y_true, y_pred, multioutput = _check_reg_targets(\n-        y_true, y_pred, multioutput, dtype=dtype, xp=xp\n+    xp, _ = get_namespace(y_true, y_pred, sample_weight, multioutput)\n+    _, y_true, y_pred, sample_weight, multioutput = (\n+        _check_reg_targets_with_floating_dtype(\n+            y_true, y_pred, sample_weight, multioutput, xp=xp\n+        )\n     )\n     check_consistent_length(y_true, y_pred, sample_weight)\n-    epsilon = xp.asarray(xp.finfo(xp.float64).eps, dtype=dtype)\n-    y_true_abs = xp.asarray(xp.abs(y_true), dtype=dtype)\n-    mape = xp.asarray(xp.abs(y_pred - y_true), dtype=dtype) / xp.maximum(\n-        y_true_abs, epsilon\n-    )\n+    epsilon = xp.asarray(xp.finfo(xp.float64).eps, dtype=y_true.dtype)\n+    y_true_abs = xp.abs(y_true)\n+    mape = xp.abs(y_pred - y_true) / xp.maximum(y_true_abs, epsilon)\n     output_errors = _average(mape, weights=sample_weight, axis=0)\n     if isinstance(multioutput, str):\n         if multioutput == \"raw_values\":\n@@ -494,10 +561,10 @@ def mean_squared_error(\n     0.825...\n     \"\"\"\n     xp, _ = get_namespace(y_true, y_pred, sample_weight, multioutput)\n-    dtype = _find_matching_floating_dtype(y_true, y_pred, xp=xp)\n-\n-    _, y_true, y_pred, multioutput = _check_reg_targets(\n-        y_true, y_pred, multioutput, dtype=dtype, xp=xp\n+    _, y_true, y_pred, sample_weight, multioutput = (\n+        _check_reg_targets_with_floating_dtype(\n+            y_true, y_pred, sample_weight, multioutput, xp=xp\n+        )\n     )\n     check_consistent_length(y_true, y_pred, sample_weight)\n     output_errors = _average((y_true - y_pred) ** 2, axis=0, weights=sample_weight)\n@@ -670,10 +737,9 @@ def mean_squared_log_error(\n     0.060...\n     \"\"\"\n     xp, _ = get_namespace(y_true, y_pred)\n-    dtype = _find_matching_floating_dtype(y_true, y_pred, xp=xp)\n \n-    _, y_true, y_pred, _ = _check_reg_targets(\n-        y_true, y_pred, multioutput, dtype=dtype, xp=xp\n+    _, y_true, y_pred, _, _ = _check_reg_targets_with_floating_dtype(\n+        y_true, y_pred, sample_weight, multioutput, xp=xp\n     )\n \n     if xp.any(y_true <= -1) or xp.any(y_pred <= -1):\n@@ -747,10 +813,9 @@ def root_mean_squared_log_error(\n     0.199...\n     \"\"\"\n     xp, _ = get_namespace(y_true, y_pred)\n-    dtype = _find_matching_floating_dtype(y_true, y_pred, xp=xp)\n \n-    _, y_true, y_pred, multioutput = _check_reg_targets(\n-        y_true, y_pred, multioutput, dtype=dtype, xp=xp\n+    _, y_true, y_pred, _, _ = _check_reg_targets_with_floating_dtype(\n+        y_true, y_pred, sample_weight, multioutput, xp=xp\n     )\n \n     if xp.any(y_true <= -1) or xp.any(y_pred <= -1):\n@@ -1188,11 +1253,12 @@ def r2_score(\n         y_true, y_pred, sample_weight, multioutput\n     )\n \n-    dtype = _find_matching_floating_dtype(y_true, y_pred, sample_weight, xp=xp)\n-\n-    _, y_true, y_pred, multioutput = _check_reg_targets(\n-        y_true, y_pred, multioutput, dtype=dtype, xp=xp\n+    _, y_true, y_pred, sample_weight, multioutput = (\n+        _check_reg_targets_with_floating_dtype(\n+            y_true, y_pred, sample_weight, multioutput, xp=xp\n+        )\n     )\n+\n     check_consistent_length(y_true, y_pred, sample_weight)\n \n     if _num_samples(y_pred) < 2:\n@@ -1201,7 +1267,7 @@ def r2_score(\n         return float(\"nan\")\n \n     if sample_weight is not None:\n-        sample_weight = column_or_1d(sample_weight, dtype=dtype)\n+        sample_weight = column_or_1d(sample_weight)\n         weight = sample_weight[:, None]\n     else:\n         weight = 1.0\n@@ -1356,8 +1422,8 @@ def mean_tweedie_deviance(y_true, y_pred, *, sample_weight=None, power=0):\n     1.4260...\n     \"\"\"\n     xp, _ = get_namespace(y_true, y_pred)\n-    y_type, y_true, y_pred, _ = _check_reg_targets(\n-        y_true, y_pred, None, dtype=[xp.float64, xp.float32], xp=xp\n+    y_type, y_true, y_pred, sample_weight, _ = _check_reg_targets_with_floating_dtype(\n+        y_true, y_pred, sample_weight, multioutput=None, xp=xp\n     )\n     if y_type == \"continuous-multioutput\":\n         raise ValueError(\"Multioutput not supported in mean_tweedie_deviance\")\n@@ -1570,8 +1636,8 @@ def d2_tweedie_score(y_true, y_pred, *, sample_weight=None, power=0):\n     \"\"\"\n     xp, _ = get_namespace(y_true, y_pred)\n \n-    y_type, y_true, y_pred, _ = _check_reg_targets(\n-        y_true, y_pred, None, dtype=[xp.float64, xp.float32], xp=xp\n+    y_type, y_true, y_pred, sample_weight, _ = _check_reg_targets_with_floating_dtype(\n+        y_true, y_pred, sample_weight, multioutput=None, xp=xp\n     )\n     if y_type == \"continuous-multioutput\":\n         raise ValueError(\"Multioutput not supported in d2_tweedie_score\")\ndiff --git a/sklearn/metrics/tests/test_common.py b/sklearn/metrics/tests/test_common.py\nindex e6abc8c433013..30722c5eab52f 100644\n--- a/sklearn/metrics/tests/test_common.py\n+++ b/sklearn/metrics/tests/test_common.py\n@@ -583,8 +583,8 @@ def _require_positive_targets(y1, y2):\n def _require_log1p_targets(y1, y2):\n     \"\"\"Make targets strictly larger than -1\"\"\"\n     offset = abs(min(y1.min(), y2.min())) - 0.99\n-    y1 = y1.astype(float)\n-    y2 = y2.astype(float)\n+    y1 = y1.astype(np.float64)\n+    y2 = y2.astype(np.float64)\n     y1 += offset\n     y2 += offset\n     return y1, y2\n",
  "fail_to_pass": [],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/metrics/_regression.py",
    "sklearn/metrics/tests/test_common.py"
  ],
  "difficulty": "medium",
  "created_at": "2024-10-22T00:08:55Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/30128",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/pull/1234"
}