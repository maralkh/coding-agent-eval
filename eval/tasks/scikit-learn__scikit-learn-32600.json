{
  "id": "scikit-learn__scikit-learn-32600",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "cc2e1aaf1d662219dfa76ac8481f04163d3a594a",
  "issue_number": 26024,
  "issue_title": "Make more of the \"tools\" of scikit-learn Array API compatible",
  "issue_body": "\ud83d\udea8 \ud83d\udea7 This issue requires a bit of patience and experience to contribute to \ud83d\udea7 \ud83d\udea8 \r\n\r\n- Original issue introducing array API in scikit-learn: #22352\r\n- array API official doc/spec: https://data-apis.org/array-api/\r\n- scikit-learn doc: https://scikit-learn.org/dev/modules/array_api.html\r\n\r\nPlease mention this issue when you create a PR, but please don't write \"closes #26024\" or \"fixes #26024\".\r\n\r\nscikit-learn contains lots of useful tools, in addition to the many estimators it has. For example [metrics](https://scikit-learn.org/stable/modules/classes.html#sklearn-metrics-metrics), [pipelines](https://scikit-learn.org/stable/modules/classes.html#module-sklearn.pipeline), [pre-processing](https://scikit-learn.org/stable/modules/classes.html#module-sklearn.preprocessing) and [mode selection](https://scikit-learn.org/stable/modules/classes.html#module-sklearn.model_selection). These are useful to and used by people who do not necessarily use an estimator from scikit-learn. This is great.\r\n\r\nThe fact that many users install scikit-learn \"just\" to use `train_test_split` is a testament to how useful it is to provide easy to use tools that do the right(!) thing. Instead of everyone implementing them from scratch because it is \"easy\" and making mistakes along the way.\r\n\r\nIn this issue I'd like to collect and track work related to making it easier to use all these \"tools\" from scikit-learn even if you are not using Numpy arrays for your data. In particular thanks to the Array API standard it should be \"not too much work\" to make things usable with data that is in an array that conforms to the Array API standard.\r\n\r\nThere is work in #25956 and #22554 which adds the basic infrastructure needed to use \"array API arrays\".\r\n\r\nThe goal of this issue is to make code like the following work:\r\n```python\r\n>>> from sklearn.preprocessing import MinMaxScaler\r\n>>> from sklearn import config_context\r\n>>> from sklearn.datasets import make_classification\r\n>>> import torch\r\n>>> X_np, y_np = make_classification(random_state=0)\r\n>>> X_torch = torch.asarray(X_np, device=\"cuda\", dtype=torch.float32)\r\n>>> y_torch = torch.asarray(y_np, device=\"cuda\", dtype=torch.float32)\r\n\r\n>>> with config_context(array_api_dispatch=True):\r\n...     # For example using MinMaxScaler on PyTorch tensors\r\n...     scale = MinMaxScaler()\r\n...     X_trans = scale.fit_transform(X_torch, y_torch)\r\n...     assert type(X_trans) == type(X_torch)\r\n...     assert X_trans.device == X_torch.device\r\n```\r\n\r\nThe first step (or maybe part of the first) is to check which of them already \"just work\". After that is done we can start the work (one PR per class/function) making changes.\r\n\r\n\r\n## Guidelines for testing\r\n\r\nGeneral comment: most of the time when we add array API support to a function in scikit-learn, we do not touch the existing (numpy-only) tests to make sure that the PR does not change the default behavior of scikit-learn on traditional inputs when array API is not enabled.\r\n\r\nIn the case of an estimator, it can be enough to add the `array_api_support=True` estimator tag in a method named `__sklearn_tags__`. For metric functions, just register it in the `array_api_metric_checkers` in `sklearn/metrics/tests/test_common.py` to include it in the common test.\r\n\r\nFor other kinds of functions not covered by existing common tests, or when the array API support depends heavily on non-default values, it might be required to add one or more new test functions to the related module-level test file. The general testing scheme is the following:\r\n\r\n- generate some random test data with numpy or `sklearn.datasets.make_*`;\r\n- call the function once on the numpy inputs without enabling array API dispatch;\r\n- convert the inputs to a namespace / device combo passed as parameter to the test;\r\n- call the function with array API dispatching enabled (under a `with sklearn.config_context(array_api_dispatch=True)` block\r\n- check that the results are on the same namespace and device as the input\r\n- convert back the output to a numpy array using `_convert_to_numpy`\r\n- compare the original / reference numpy results and the `xp` computation results converted back to numpy using `assert_allclose` or similar.\r\n\r\nThose tests should have `array_api` somewhere in their name to makes sure that we can run all the array API compliance tests with a keyword search in the pytest command line, e.g.:\r\n\r\n```\r\npytest -k array_api sklearn/some/subpackage\r\n```\r\n\r\nIn particular, for cost reasons, our CUDA GPU CI only runs `pytest -k array_api sklearn`. So it's very important to respect this naming conventions, otherwise we will not tests all what we are supposed to test on CUDA.\r\n\r\nMore generally, look at merged array API pull requests to see how testing is typically handled.",
  "pr_number": 32600,
  "pr_title": "Add array API support to `calinski_harabasz_score`",
  "gold_patch": "diff --git a/doc/modules/array_api.rst b/doc/modules/array_api.rst\nindex 36cc79efa5793..b9b46f99f3cae 100644\n--- a/doc/modules/array_api.rst\n+++ b/doc/modules/array_api.rst\n@@ -149,6 +149,7 @@ Metrics\n - :func:`sklearn.metrics.accuracy_score`\n - :func:`sklearn.metrics.balanced_accuracy_score`\n - :func:`sklearn.metrics.brier_score_loss`\n+- :func:`sklearn.metrics.cluster.calinski_harabasz_score`\n - :func:`sklearn.metrics.cohen_kappa_score`\n - :func:`sklearn.metrics.confusion_matrix`\n - :func:`sklearn.metrics.d2_brier_score`\ndiff --git a/doc/whats_new/upcoming_changes/array-api/32600.feature.rst b/doc/whats_new/upcoming_changes/array-api/32600.feature.rst\nnew file mode 100644\nindex 0000000000000..d0a307bb2587d\n--- /dev/null\n+++ b/doc/whats_new/upcoming_changes/array-api/32600.feature.rst\n@@ -0,0 +1,2 @@\n+- :func:`sklearn.metrics.cluster.calinski_harabasz_score` now supports Array API compliant inputs.\n+  By :user:`Josef Affourtit <jaffourt>`.\ndiff --git a/sklearn/metrics/cluster/_unsupervised.py b/sklearn/metrics/cluster/_unsupervised.py\nindex 2a324343faf98..40e6bda6412dd 100644\n--- a/sklearn/metrics/cluster/_unsupervised.py\n+++ b/sklearn/metrics/cluster/_unsupervised.py\n@@ -9,6 +9,7 @@\n import numpy as np\n from scipy.sparse import issparse\n \n+from sklearn.externals.array_api_compat import is_numpy_array\n from sklearn.metrics.pairwise import (\n     _VALID_METRICS,\n     pairwise_distances,\n@@ -16,7 +17,13 @@\n )\n from sklearn.preprocessing import LabelEncoder\n from sklearn.utils import _safe_indexing, check_random_state, check_X_y\n-from sklearn.utils._array_api import xpx\n+from sklearn.utils._array_api import (\n+    _convert_to_numpy,\n+    _is_numpy_namespace,\n+    _max_precision_float_dtype,\n+    get_namespace_and_device,\n+    xpx,\n+)\n from sklearn.utils._param_validation import Interval, StrOptions, validate_params\n \n \n@@ -362,22 +369,31 @@ def calinski_harabasz_score(X, labels):\n     >>> calinski_harabasz_score(X, kmeans.labels_)\n     114.8...\n     \"\"\"\n+\n+    xp, _, device_ = get_namespace_and_device(X, labels)\n+\n+    if _is_numpy_namespace(xp) and not is_numpy_array(X):\n+        # This is required to handle the case where `array_api_dispatch` is False but\n+        # we are still dealing with `X` as a non-NumPy array e.g. a PyTorch tensor.\n+        X = _convert_to_numpy(X, xp=xp)\n+    else:\n+        X = xp.astype(X, _max_precision_float_dtype(xp, device_), copy=False)\n     X, labels = check_X_y(X, labels)\n     le = LabelEncoder()\n     labels = le.fit_transform(labels)\n \n     n_samples, _ = X.shape\n-    n_labels = len(le.classes_)\n+    n_labels = le.classes_.shape[0]\n \n     check_number_of_labels(n_labels, n_samples)\n \n     extra_disp, intra_disp = 0.0, 0.0\n-    mean = np.mean(X, axis=0)\n+    mean = xp.mean(X, axis=0)\n     for k in range(n_labels):\n         cluster_k = X[labels == k]\n-        mean_k = np.mean(cluster_k, axis=0)\n-        extra_disp += len(cluster_k) * np.sum((mean_k - mean) ** 2)\n-        intra_disp += np.sum((cluster_k - mean_k) ** 2)\n+        mean_k = xp.mean(cluster_k, axis=0)\n+        extra_disp += cluster_k.shape[0] * xp.sum((mean_k - mean) ** 2)\n+        intra_disp += xp.sum((cluster_k - mean_k) ** 2)\n \n     return float(\n         1.0\ndiff --git a/sklearn/metrics/cluster/tests/test_common.py b/sklearn/metrics/cluster/tests/test_common.py\nindex a73670fbffce4..b34b935ca95fe 100644\n--- a/sklearn/metrics/cluster/tests/test_common.py\n+++ b/sklearn/metrics/cluster/tests/test_common.py\n@@ -18,6 +18,11 @@\n     silhouette_score,\n     v_measure_score,\n )\n+from sklearn.metrics.tests.test_common import check_array_api_metric\n+from sklearn.utils._array_api import (\n+    _get_namespace_device_dtype_ids,\n+    yield_namespace_device_dtype_combinations,\n+)\n from sklearn.utils._testing import assert_allclose\n \n # Dictionaries of metrics\n@@ -232,3 +237,40 @@ def test_returned_value_consistency(name):\n \n     assert isinstance(score, float)\n     assert not isinstance(score, (np.float64, np.float32))\n+\n+\n+def check_array_api_unsupervised_metric(metric, array_namespace, device, dtype_name):\n+    y_pred = np.array([1, 0, 1, 0, 1, 1, 0])\n+    X = np.random.randint(10, size=(7, 10))\n+\n+    check_array_api_metric(\n+        metric,\n+        array_namespace,\n+        device,\n+        dtype_name,\n+        a_np=X,\n+        b_np=y_pred,\n+    )\n+\n+\n+array_api_metric_checkers = {\n+    calinski_harabasz_score: [\n+        check_array_api_unsupervised_metric,\n+    ]\n+}\n+\n+\n+def yield_metric_checker_combinations(metric_checkers=array_api_metric_checkers):\n+    for metric, checkers in metric_checkers.items():\n+        for checker in checkers:\n+            yield metric, checker\n+\n+\n+@pytest.mark.parametrize(\n+    \"array_namespace, device, dtype_name\",\n+    yield_namespace_device_dtype_combinations(),\n+    ids=_get_namespace_device_dtype_ids,\n+)\n+@pytest.mark.parametrize(\"metric, check_func\", yield_metric_checker_combinations())\n+def test_array_api_compliance(metric, array_namespace, device, dtype_name, check_func):\n+    check_func(metric, array_namespace, device, dtype_name)\n",
  "fail_to_pass": [
    "test_array_api_compliance"
  ],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/metrics/cluster/_unsupervised.py",
    "sklearn/metrics/cluster/tests/test_common.py"
  ],
  "difficulty": "hard",
  "created_at": "2025-10-28T17:02:22Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/32600",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/issues/26024"
}