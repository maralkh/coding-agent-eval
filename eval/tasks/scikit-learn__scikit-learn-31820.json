{
  "id": "scikit-learn__scikit-learn-31820",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "faf69cbf3814f7d14387c8bea64f9d04aaca12ab",
  "issue_number": 31717,
  "issue_title": "SimpleImputer fails in \"most_frequent\" if incomparable types only if ties",
  "issue_body": "### Describe the bug\n\n### Observed behavior\n\nWhen using the \"most_frequent\" strategy from SimpleImputer and there is a tie, the code takes the minimum values among all ties. This crashes if the values are not comparable such as `str` and `NoneType`.\n\n### Steps/Code to Reproduce\n\n```python\nimport numpy as np\nfrom sklearn.impute import SimpleImputer\n\n\nX1 = np.asarray(['a', None])[:, None]\nX2 = np.asarray(['a', None, None])[:, None]\n\nimputer = SimpleImputer(add_indicator=True, strategy=\"most_frequent\")\n\ntry:\n    imputer.fit_transform(X1)\n    print('X1 processed successfully')\nexcept Exception as e:\n    print('Error while processing X1:', e)\n\n\ntry:\n    imputer.fit_transform(X2)\n    print('X2 processed successfully')\nexcept Exception as e:\n    print('Error while processing X2:', e)\n```\n\n### Expected Results\n\nI would expect the Imputer to have a consistant behavior not depending on whether or not a tie is presente. Namely:\n* Run whether or not values are comparable\n* Crashes if values are not comparable, wheter there is a tie or not.\n\nNote that the code claims to process data like `scipy.stats.mode` but `mode` only processes numeric values since scipy 1.9.0, it therefore crashed on this example and redirect the user toward `np.unique`:\n\n```\nTraceback (most recent call last):\n  File \"/Users/aabraham/NeuralkFoundry/tutorials/repro.py\", line 11, in <module>\n    print(scipy.stats.mode(X1))\n          ~~~~~~~~~~~~~~~~^^^^\n  File \"/Users/aabraham/.local/share/mamba/envs/skle/lib/python3.13/site-packages/scipy/stats/_axis_nan_policy.py\", line 611, in axis_nan_policy_wrapper\n    res = hypotest_fun_out(*samples, axis=axis, **kwds)\n  File \"/Users/aabraham/.local/share/mamba/envs/skle/lib/python3.13/site-packages/scipy/stats/_stats_py.py\", line 567, in mode\n    raise TypeError(message)\nTypeError: Argument `a` is not recognized as numeric. Support for input that cannot be coerced to a numeric array was deprecated in SciPy 1.9.0 and removed in SciPy 1.11.0. Please consider `np.unique`.\n```\n\nLet me know the correct behavior you expect and I can contribute a PR. A quick way to solve it would be to use `hash(value)` in case values are not comparable.\n\n### Actual Results\n\nError while processing X1: '<' not supported between instances of 'NoneType' and 'str'\nX2 processed successfully\n\nIf the error is not catched, here is the stack trace:\n\n```\nTraceback (most recent call last):\n  File \"/Users/aabraham/NeuralkFoundry/tutorials/repro.py\", line 10, in <module>\n    imputer.fit_transform(X1)\n    ~~~~~~~~~~~~~~~~~~~~~^^^^\n  File \"/Users/aabraham/scikit-learn/sklearn/utils/_set_output.py\", line 316, in wrapped\n    data_to_wrap = f(self, X, *args, **kwargs)\n  File \"/Users/aabraham/scikit-learn/sklearn/base.py\", line 894, in fit_transform\n    return self.fit(X, **fit_params).transform(X)\n           ~~~~~~~~^^^^^^^^^^^^^^^^^\n  File \"/Users/aabraham/scikit-learn/sklearn/base.py\", line 1365, in wrapper\n    return fit_method(estimator, *args, **kwargs)\n  File \"/Users/aabraham/scikit-learn/sklearn/impute/_base.py\", line 453, in fit\n    self.statistics_ = self._dense_fit(\n                       ~~~~~~~~~~~~~~~^\n        X, self.strategy, self.missing_values, fill_value\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    )\n    ^\n  File \"/Users/aabraham/scikit-learn/sklearn/impute/_base.py\", line 565, in _dense_fit\n    most_frequent[i] = _most_frequent(row, np.nan, 0)\n                       ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^\n  File \"/Users/aabraham/scikit-learn/sklearn/impute/_base.py\", line 53, in _most_frequent\n    most_frequent_value = min(\n        value\n        for value, count in counter.items()\n        if count == most_frequent_count\n    )\nTypeError: '<' not supported between instances of 'NoneType' and 'str'\n```\n\n### Versions\n\n```shell\nSystem:\n    python: 3.13.5 | packaged by conda-forge | (main, Jun 16 2025, 08:24:05) [Clang 18.1.8 ]\nexecutable: /Users/aabraham/.local/share/mamba/envs/skle/bin/python\n   machine: macOS-15.4.1-arm64-arm-64bit-Mach-O\n\nPython dependencies:\n      sklearn: 1.8.dev0\n          pip: 25.1.1\n   setuptools: 80.9.0\n        numpy: 2.3.1\n        scipy: 1.16.0\n       Cython: 3.1.2\n       pandas: 2.3.0\n   matplotlib: 3.10.3\n       joblib: 1.5.1\nthreadpoolctl: 3.6.0\n\nBuilt with OpenMP: True\n\nthreadpoolctl info:\n       user_api: blas\n   internal_api: openblas\n    num_threads: 12\n         prefix: libopenblas\n       filepath: /Users/aabraham/.local/share/mamba/envs/skle/lib/libopenblas.0.dylib\n        version: 0.3.30\nthreading_layer: openmp\n   architecture: VORTEX\n\n       user_api: openmp\n   internal_api: openmp\n    num_threads: 12\n         prefix: libomp\n       filepath: /Users/aabraham/.local/share/mamba/envs/skle/lib/libomp.dylib\n        version: None\n```",
  "pr_number": 31820,
  "pr_title": "Fix uncomparable values in SimpleImputer tie-breaking strategy",
  "gold_patch": "diff --git a/doc/whats_new/upcoming_changes/sklearn.impute/31820.fix.rst b/doc/whats_new/upcoming_changes/sklearn.impute/31820.fix.rst\nnew file mode 100644\nindex 0000000000000..1627b0d3feeb9\n--- /dev/null\n+++ b/doc/whats_new/upcoming_changes/sklearn.impute/31820.fix.rst\n@@ -0,0 +1,3 @@\n+- Fixed a bug in :class:`impute.SimpleImputer` with `strategy=\"most_frequent\"` when\n+  there is a tie in the most frequent value and the input data has mixed types.\n+  By :user:`Alexandre Abraham <AlexandreAbraham>`.\ndiff --git a/sklearn/impute/_base.py b/sklearn/impute/_base.py\nindex 57f5a2daa7e19..d8a63330570e2 100644\n--- a/sklearn/impute/_base.py\n+++ b/sklearn/impute/_base.py\n@@ -38,6 +38,20 @@ def _check_inputs_dtype(X, missing_values):\n         )\n \n \n+def _safe_min(items):\n+    \"\"\"Compute the minimum of a list of potentially non-comparable values.\n+\n+    If values cannot be directly compared due to type incompatibility, the object with\n+    the lowest string representation is returned.\n+    \"\"\"\n+    try:\n+        return min(items)\n+    except TypeError as e:\n+        if \"'<' not supported between\" in str(e):\n+            return min(items, key=lambda x: (str(type(x)), str(x)))\n+        raise  # pragma: no cover\n+\n+\n def _most_frequent(array, extra_value, n_repeat):\n     \"\"\"Compute the most frequent value in a 1d array extended with\n     [extra_value] * n_repeat, where extra_value is assumed to be not part\n@@ -50,10 +64,12 @@ def _most_frequent(array, extra_value, n_repeat):\n             counter = Counter(array)\n             most_frequent_count = counter.most_common(1)[0][1]\n             # tie breaking similarly to scipy.stats.mode\n-            most_frequent_value = min(\n-                value\n-                for value, count in counter.items()\n-                if count == most_frequent_count\n+            most_frequent_value = _safe_min(\n+                [\n+                    value\n+                    for value, count in counter.items()\n+                    if count == most_frequent_count\n+                ]\n             )\n         else:\n             mode = _mode(array)\n@@ -72,7 +88,7 @@ def _most_frequent(array, extra_value, n_repeat):\n         return most_frequent_value\n     elif most_frequent_count == n_repeat:\n         # tie breaking similarly to scipy.stats.mode\n-        return min(most_frequent_value, extra_value)\n+        return _safe_min([most_frequent_value, extra_value])\n \n \n class _BaseImputer(TransformerMixin, BaseEstimator):\ndiff --git a/sklearn/impute/tests/test_impute.py b/sklearn/impute/tests/test_impute.py\nindex 16501b0550364..4116964c49a7a 100644\n--- a/sklearn/impute/tests/test_impute.py\n+++ b/sklearn/impute/tests/test_impute.py\n@@ -1529,6 +1529,26 @@ def test_most_frequent(expected, array, dtype, extra_value, n_repeat):\n     )\n \n \n+@pytest.mark.parametrize(\n+    \"expected,array\",\n+    [\n+        (\"a\", [\"a\", \"b\"]),\n+        (1, [1, 2]),\n+        (None, [None, \"a\"]),\n+        (None, [None, 1]),\n+        (None, [None, \"a\", 1]),\n+        (1, [1, \"1\"]),\n+        (1, [\"1\", 1]),\n+    ],\n+)\n+def test_most_frequent_tie_object(expected, array):\n+    \"\"\"Check the tie breaking behavior of the most frequent strategy.\n+\n+    Non-regression test for issue #31717.\n+    \"\"\"\n+    assert expected == _most_frequent(np.array(array, dtype=object), None, 0)\n+\n+\n @pytest.mark.parametrize(\n     \"initial_strategy\", [\"mean\", \"median\", \"most_frequent\", \"constant\"]\n )\n",
  "fail_to_pass": [
    "test_most_frequent_tie_object"
  ],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/impute/_base.py",
    "sklearn/impute/tests/test_impute.py"
  ],
  "difficulty": "medium",
  "created_at": "2025-07-22T23:12:53Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/31820",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/issues/31717"
}