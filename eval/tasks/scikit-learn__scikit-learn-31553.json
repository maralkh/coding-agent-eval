{
  "id": "scikit-learn__scikit-learn-31553",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "bde701db13cebd5d5ed0bc049fb0bc9693c6c5dc",
  "issue_number": 31546,
  "issue_title": "Regression in `DecisionBoundaryDisplay.from_estimator` with `colors` and `plot_method='contour'` after upgrading to v1.7.0",
  "issue_body": "### Describe the bug\n\nHello. Recently, after upgrading to scikit-learn v1.7.0, I encountered an issue when using `DecisionBoundaryDisplay.from_estimator` with the `colors` keyword argument. Specifically, the following error is raised:\n```python\n  File \"D:\\Project\\Python Project\\venv\\Lib\\site-packages\\sklearn\\inspection\\_plot\\decision_boundary.py\", line 276, in plot\n    plot_func(self.xx0, self.xx1, response, cmap=cmap, **safe_kwargs)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Project\\Python Project\\venv\\Lib\\site-packages\\matplotlib\\contour.py\", line 689, in __init__\n    raise ValueError('Either colors or cmap must be None')\nValueError: Either colors or cmap must be None\n```\nHowever, in v1.6.0, everything works fine.\n\nAfter further investigation, it seems this issue was introduced by PR #29797, where both `cmap` and `colors` are passed to `plot_func` unconditionally, without explicit conflict handling:\nhttps://github.com/scikit-learn/scikit-learn/blob/d4d4af8c471c60d183d0cb67e14e6434b0ebb9fb/sklearn/inspection/_plot/decision_boundary.py#L276\nAdditionally, when setting `plot_method='contour'` in multiclass classification scenarios, the decision boundary is no longer shown as it was in v1.6.0. It appears that this regression is due to the switch in v1.7.0 to always using a cmap to plot the entire decision surface in multiclass scenarios.\n\nHere are the visual differences:\n- v1.6.0 with `plot_method='contour'`:\n![Image](https://github.com/user-attachments/assets/858d2540-47d5-4637-b992-89dc9b196b08)\n- v1.7.0 with the same code:\n![Image](https://github.com/user-attachments/assets/6d7a5c0e-2df9-47c0-bc9c-3a4e0e5dbac4)\n## Suggestion\nTo preserve backward compatibility and expected behavior:\n- Check for mutual exclusivity of `colors` and `cmap` and raise a clear warning/error;\n- Retain the old behavior when `plot_method='contour'`.\n\nI'd be happy to open a PR to help address this regression if the core team is supportive.\n\n### Steps/Code to Reproduce\n\n```python\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import load_iris\nfrom sklearn.inspection import DecisionBoundaryDisplay\nfrom sklearn.linear_model import LogisticRegression\n\niris = load_iris()\nX = iris.data[:, :2]\nclassifier = LogisticRegression().fit(X, iris.target)\ndisp = DecisionBoundaryDisplay.from_estimator(\n    classifier,\n    X,\n    # plot_method='contour',\n    xlabel=iris.feature_names[0],\n    ylabel=iris.feature_names[1],\n    colors='black',\n    alpha=0.5,\n)\ndisp.ax_.scatter(X[:, 0], X[:, 1], c=iris.target, edgecolor='k')\nplt.show()\n```\n\n### Expected Results\n\nNo error is raised when using `plot_method='contour'` together with `colors`, and the decision boundary is displayed correctly as expected.\n\n### Actual Results\n\n```python\nTraceback (most recent call last):\n  File \"d:\\Project\\Python Project\\cc.py\", line 9, in <module>\n    disp = DecisionBoundaryDisplay.from_estimator(\n        classifier,\n    ...<4 lines>...\n        alpha=0.5,\n    )\n  File \"D:\\Project\\Python Project\\venv\\Lib\\site-packages\\sklearn\\inspection\\_plot\\decision_boundary.py\", line 558, in from_estimator\n    return display.plot(ax=ax, plot_method=plot_method, **kwargs)\n           ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Project\\Python Project\\venv\\Lib\\site-packages\\sklearn\\inspection\\_plot\\decision_boundary.py\", line 276, in plot\n    plot_func(self.xx0, self.xx1, response, cmap=cmap, **safe_kwargs)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Project\\Python Project\\venv\\Lib\\site-packages\\matplotlib\\__init__.py\", line 1521, in inner\n    return func(\n        ax,\n        *map(cbook.sanitize_sequence, args),\n        **{k: cbook.sanitize_sequence(v) for k, v in kwargs.items()})\n  File \"D:\\Project\\Python Project\\venv\\Lib\\site-packages\\matplotlib\\axes\\_axes.py\", line 6794, in contourf\n    contours = mcontour.QuadContourSet(self, *args, **kwargs)\n  File \"D:\\Project\\Python Project\\venv\\Lib\\site-packages\\matplotlib\\contour.py\", line 689, in __init__\n    raise ValueError('Either colors or cmap must be None')\nValueError: Either colors or cmap must be None\n```\n\n### Versions\n\n```shell\nSystem:\n    python: 3.13.4 (tags/v3.13.4:8a526ec, Jun  3 2025, 17:46:04) [MSC v.1943 64 bit (AMD64)]\nexecutable: D:\\Project\\Python Project\\venv\\Scripts\\python.exe\n   machine: Windows-11-10.0.26100-SP0\n\nPython dependencies:\n      sklearn: 1.7.0\n          pip: None\n   setuptools: 80.9.0\n        numpy: 2.3.0\n        scipy: 1.15.3\n       Cython: 3.1.2\n       pandas: 2.3.0\n   matplotlib: 3.10.3\n       joblib: 1.5.1\nthreadpoolctl: 3.6.0\n\nBuilt with OpenMP: True\n\nthreadpoolctl info:\n       user_api: openmp\n   internal_api: openmp\n    num_threads: 16\n         prefix: vcomp\n       filepath: D:\\Project\\Python Project\\venv\\Lib\\site-packages\\sklearn\\.libs\\vcomp140.dll\n        version: None\n\n       user_api: blas\n   internal_api: openblas\n    num_threads: 16\n         prefix: libscipy_openblas\n       filepath: D:\\Project\\Python Project\\venv\\Lib\\site-packages\\numpy.libs\\libscipy_openblas64_-13e2df515630b4a41f92893938845698.dll\n        version: 0.3.29\nthreading_layer: pthreads\n   architecture: Haswell\n\n       user_api: blas\n   internal_api: openblas\n    num_threads: 16\n         prefix: libscipy_openblas\n       filepath: D:\\Project\\Python Project\\venv\\Lib\\site-packages\\scipy.libs\\libscipy_openblas-f07f5a5d207a3a47104dca54d6d0c86a.dll\n        version: 0.3.28\nthreading_layer: pthreads\n   architecture: Haswell\n```",
  "pr_number": 31553,
  "pr_title": "FIX: Regression in DecisionBoundaryDisplay.from_estimator with colors and plot_method='contour'",
  "gold_patch": "diff --git a/doc/whats_new/upcoming_changes/sklearn.inspection/31553.fix.rst b/doc/whats_new/upcoming_changes/sklearn.inspection/31553.fix.rst\nnew file mode 100644\nindex 0000000000000..bd9bb339bb68c\n--- /dev/null\n+++ b/doc/whats_new/upcoming_changes/sklearn.inspection/31553.fix.rst\n@@ -0,0 +1,7 @@\n+- Fix multiple issues in the multiclass setting of :class:`inspection.DecisionBoundaryDisplay`:\n+\n+  - `contour` plotting now correctly shows the decision boundary.\n+  - `cmap` and `colors` are now properly ignored in favor of `multiclass_colors`.\n+  - Linear segmented colormaps are now fully supported.\n+\n+  By :user:`Yunjie Lin <jshn9515>`\ndiff --git a/sklearn/inspection/_plot/decision_boundary.py b/sklearn/inspection/_plot/decision_boundary.py\nindex bc28708d7c488..2ef8538058393 100644\n--- a/sklearn/inspection/_plot/decision_boundary.py\n+++ b/sklearn/inspection/_plot/decision_boundary.py\n@@ -221,17 +221,22 @@ def plot(self, plot_method=\"contourf\", ax=None, xlabel=None, ylabel=None, **kwar\n             self.surface_ = plot_func(self.xx0, self.xx1, self.response, **kwargs)\n         else:  # self.response.ndim == 3\n             n_responses = self.response.shape[-1]\n-            if (\n-                isinstance(self.multiclass_colors, str)\n-                or self.multiclass_colors is None\n+            for kwarg in (\"cmap\", \"colors\"):\n+                if kwarg in kwargs:\n+                    warnings.warn(\n+                        f\"'{kwarg}' is ignored in favor of 'multiclass_colors' \"\n+                        \"in the multiclass case when the response method is \"\n+                        \"'decision_function' or 'predict_proba'.\"\n+                    )\n+                    del kwargs[kwarg]\n+\n+            if self.multiclass_colors is None or isinstance(\n+                self.multiclass_colors, str\n             ):\n-                if isinstance(self.multiclass_colors, str):\n-                    cmap = self.multiclass_colors\n+                if self.multiclass_colors is None:\n+                    cmap = \"tab10\" if n_responses <= 10 else \"gist_rainbow\"\n                 else:\n-                    if n_responses <= 10:\n-                        cmap = \"tab10\"\n-                    else:\n-                        cmap = \"gist_rainbow\"\n+                    cmap = self.multiclass_colors\n \n                 # Special case for the tab10 and tab20 colormaps that encode a\n                 # discrete set of colors that are easily distinguishable\n@@ -241,40 +246,41 @@ def plot(self, plot_method=\"contourf\", ax=None, xlabel=None, ylabel=None, **kwar\n                 elif cmap == \"tab20\" and n_responses <= 20:\n                     colors = plt.get_cmap(\"tab20\", 20).colors[:n_responses]\n                 else:\n-                    colors = plt.get_cmap(cmap, n_responses).colors\n-            elif isinstance(self.multiclass_colors, str):\n-                colors = colors = plt.get_cmap(\n-                    self.multiclass_colors, n_responses\n-                ).colors\n-            else:\n+                    cmap = plt.get_cmap(cmap, n_responses)\n+                    if not hasattr(cmap, \"colors\"):\n+                        # For LinearSegmentedColormap\n+                        colors = cmap(np.linspace(0, 1, n_responses))\n+                    else:\n+                        colors = cmap.colors\n+            elif isinstance(self.multiclass_colors, list):\n                 colors = [mpl.colors.to_rgba(color) for color in self.multiclass_colors]\n+            else:\n+                raise ValueError(\"'multiclass_colors' must be a list or a str.\")\n \n             self.multiclass_colors_ = colors\n-            multiclass_cmaps = [\n-                mpl.colors.LinearSegmentedColormap.from_list(\n-                    f\"colormap_{class_idx}\", [(1.0, 1.0, 1.0, 1.0), (r, g, b, 1.0)]\n-                )\n-                for class_idx, (r, g, b, _) in enumerate(colors)\n-            ]\n-\n-            self.surface_ = []\n-            for class_idx, cmap in enumerate(multiclass_cmaps):\n-                response = np.ma.array(\n-                    self.response[:, :, class_idx],\n-                    mask=~(self.response.argmax(axis=2) == class_idx),\n+            if plot_method == \"contour\":\n+                # Plot only argmax map for contour\n+                class_map = self.response.argmax(axis=2)\n+                self.surface_ = plot_func(\n+                    self.xx0, self.xx1, class_map, colors=colors, **kwargs\n                 )\n-                # `cmap` should not be in kwargs\n-                safe_kwargs = kwargs.copy()\n-                if \"cmap\" in safe_kwargs:\n-                    del safe_kwargs[\"cmap\"]\n-                    warnings.warn(\n-                        \"Plotting max class of multiclass 'decision_function' or \"\n-                        \"'predict_proba', thus 'multiclass_colors' used and \"\n-                        \"'cmap' kwarg ignored.\"\n+            else:\n+                multiclass_cmaps = [\n+                    mpl.colors.LinearSegmentedColormap.from_list(\n+                        f\"colormap_{class_idx}\", [(1.0, 1.0, 1.0, 1.0), (r, g, b, 1.0)]\n+                    )\n+                    for class_idx, (r, g, b, _) in enumerate(colors)\n+                ]\n+\n+                self.surface_ = []\n+                for class_idx, cmap in enumerate(multiclass_cmaps):\n+                    response = np.ma.array(\n+                        self.response[:, :, class_idx],\n+                        mask=~(self.response.argmax(axis=2) == class_idx),\n+                    )\n+                    self.surface_.append(\n+                        plot_func(self.xx0, self.xx1, response, cmap=cmap, **kwargs)\n                     )\n-                self.surface_.append(\n-                    plot_func(self.xx0, self.xx1, response, cmap=cmap, **safe_kwargs)\n-                )\n \n         if xlabel is not None or not ax.get_xlabel():\n             xlabel = self.xlabel if xlabel is None else xlabel\ndiff --git a/sklearn/inspection/_plot/tests/test_boundary_decision_display.py b/sklearn/inspection/_plot/tests/test_boundary_decision_display.py\nindex 3284f42241fa5..f409a50ab58c0 100644\n--- a/sklearn/inspection/_plot/tests/test_boundary_decision_display.py\n+++ b/sklearn/inspection/_plot/tests/test_boundary_decision_display.py\n@@ -169,6 +169,10 @@ def test_input_validation_errors(pyplot, kwargs, error_msg, fitted_clf):\n @pytest.mark.parametrize(\n     \"kwargs, error_msg\",\n     [\n+        (\n+            {\"multiclass_colors\": {\"dict\": \"not_list\"}},\n+            \"'multiclass_colors' must be a list or a str.\",\n+        ),\n         ({\"multiclass_colors\": \"not_cmap\"}, \"it must be a valid Matplotlib colormap\"),\n         ({\"multiclass_colors\": [\"red\", \"green\"]}, \"it must be of the same length\"),\n         (\n@@ -617,6 +621,7 @@ def test_multiclass_plot_max_class(pyplot, response_method):\n     \"multiclass_colors\",\n     [\n         \"plasma\",\n+        \"Blues\",\n         [\"red\", \"green\", \"blue\"],\n     ],\n )\n@@ -642,31 +647,51 @@ def test_multiclass_colors_cmap(pyplot, plot_method, multiclass_colors):\n \n     if multiclass_colors == \"plasma\":\n         colors = mpl.pyplot.get_cmap(multiclass_colors, len(clf.classes_)).colors\n+    elif multiclass_colors == \"Blues\":\n+        cmap = mpl.pyplot.get_cmap(multiclass_colors, len(clf.classes_))\n+        colors = cmap(np.linspace(0, 1, len(clf.classes_)))\n     else:\n         colors = [mpl.colors.to_rgba(color) for color in multiclass_colors]\n \n-    cmaps = [\n-        mpl.colors.LinearSegmentedColormap.from_list(\n-            f\"colormap_{class_idx}\", [(1.0, 1.0, 1.0, 1.0), (r, g, b, 1.0)]\n-        )\n-        for class_idx, (r, g, b, _) in enumerate(colors)\n-    ]\n-\n-    for idx, quad in enumerate(disp.surface_):\n-        assert quad.cmap == cmaps[idx]\n+    if plot_method != \"contour\":\n+        cmaps = [\n+            mpl.colors.LinearSegmentedColormap.from_list(\n+                f\"colormap_{class_idx}\", [(1.0, 1.0, 1.0, 1.0), (r, g, b, 1.0)]\n+            )\n+            for class_idx, (r, g, b, _) in enumerate(colors)\n+        ]\n+        for idx, quad in enumerate(disp.surface_):\n+            assert quad.cmap == cmaps[idx]\n+    else:\n+        assert_allclose(disp.surface_.colors, colors)\n \n \n-def test_multiclass_plot_max_class_cmap_kwarg(pyplot):\n-    \"\"\"Check `cmap` kwarg ignored when using plotting max multiclass class.\"\"\"\n+def test_cmap_and_colors_logic(pyplot):\n+    \"\"\"Check the handling logic for `cmap` and `colors`.\"\"\"\n     X, y = load_iris_2d_scaled()\n     clf = LogisticRegression().fit(X, y)\n \n-    msg = (\n-        \"Plotting max class of multiclass 'decision_function' or 'predict_proba', \"\n-        \"thus 'multiclass_colors' used and 'cmap' kwarg ignored.\"\n-    )\n-    with pytest.warns(UserWarning, match=msg):\n-        DecisionBoundaryDisplay.from_estimator(clf, X, cmap=\"viridis\")\n+    with pytest.warns(\n+        UserWarning,\n+        match=\"'cmap' is ignored in favor of 'multiclass_colors'\",\n+    ):\n+        DecisionBoundaryDisplay.from_estimator(\n+            clf,\n+            X,\n+            multiclass_colors=\"plasma\",\n+            cmap=\"Blues\",\n+        )\n+\n+    with pytest.warns(\n+        UserWarning,\n+        match=\"'colors' is ignored in favor of 'multiclass_colors'\",\n+    ):\n+        DecisionBoundaryDisplay.from_estimator(\n+            clf,\n+            X,\n+            multiclass_colors=\"plasma\",\n+            colors=\"blue\",\n+        )\n \n \n def test_subclass_named_constructors_return_type_is_subclass(pyplot):\n",
  "fail_to_pass": [
    "test_cmap_and_colors_logic"
  ],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/inspection/_plot/decision_boundary.py",
    "sklearn/inspection/_plot/tests/test_boundary_decision_display.py"
  ],
  "difficulty": "medium",
  "created_at": "2025-06-16T05:50:09Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/31553",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/issues/31546"
}