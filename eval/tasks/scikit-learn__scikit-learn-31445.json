{
  "id": "scikit-learn__scikit-learn-31445",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "cc526ee76c38a5b1522da9172d5332f952cd4cac",
  "issue_number": 29822,
  "issue_title": "Array API support for pairwise kernels",
  "issue_body": "#### Reference Issues/PRs\r\n(hopefully) unblocks progress with #29661 \r\n\r\n#### What does this implement/fix? Explain your changes.\r\nAdding array API support for `pairwise_kernels`\r\n\r\n#### To do \r\n- [x] `_parallel_pairwise`\r\n- [x] `_pairwise_callable`\r\n- [x] Add tests in `test_pairwise.py` (`pairwise_distances` and `pairwise_kernels` in particular) \r\n- [x] Changelog ",
  "pr_number": 31445,
  "pr_title": "Fix `_fill_or_add_to_diagonal` when `reshape` returns copy",
  "gold_patch": "diff --git a/sklearn/decomposition/_base.py b/sklearn/decomposition/_base.py\nindex 783c316b50f27..85cc746fd9b8a 100644\n--- a/sklearn/decomposition/_base.py\n+++ b/sklearn/decomposition/_base.py\n@@ -9,7 +9,7 @@\n from scipy import linalg\n \n from ..base import BaseEstimator, ClassNamePrefixFeaturesOutMixin, TransformerMixin\n-from ..utils._array_api import _fill_or_add_to_diagonal, device, get_namespace\n+from ..utils._array_api import _add_to_diagonal, device, get_namespace\n from ..utils.validation import check_is_fitted, validate_data\n \n \n@@ -47,7 +47,7 @@ def get_covariance(self):\n             xp.asarray(0.0, device=device(exp_var), dtype=exp_var.dtype),\n         )\n         cov = (components_.T * exp_var_diff) @ components_\n-        _fill_or_add_to_diagonal(cov, self.noise_variance_, xp)\n+        _add_to_diagonal(cov, self.noise_variance_, xp)\n         return cov\n \n     def get_precision(self):\n@@ -89,10 +89,10 @@ def get_precision(self):\n             xp.asarray(0.0, device=device(exp_var)),\n         )\n         precision = components_ @ components_.T / self.noise_variance_\n-        _fill_or_add_to_diagonal(precision, 1.0 / exp_var_diff, xp)\n+        _add_to_diagonal(precision, 1.0 / exp_var_diff, xp)\n         precision = components_.T @ linalg_inv(precision) @ components_\n         precision /= -(self.noise_variance_**2)\n-        _fill_or_add_to_diagonal(precision, 1.0 / self.noise_variance_, xp)\n+        _add_to_diagonal(precision, 1.0 / self.noise_variance_, xp)\n         return precision\n \n     @abstractmethod\ndiff --git a/sklearn/metrics/pairwise.py b/sklearn/metrics/pairwise.py\nindex 95d91fbd205f1..00cf27e4db519 100644\n--- a/sklearn/metrics/pairwise.py\n+++ b/sklearn/metrics/pairwise.py\n@@ -19,7 +19,7 @@\n from ..preprocessing import normalize\n from ..utils import check_array, gen_batches, gen_even_slices\n from ..utils._array_api import (\n-    _fill_or_add_to_diagonal,\n+    _fill_diagonal,\n     _find_matching_floating_dtype,\n     _is_numpy_namespace,\n     _max_precision_float_dtype,\n@@ -439,7 +439,7 @@ def _euclidean_distances(X, Y, X_norm_squared=None, Y_norm_squared=None, squared\n     # Ensure that distances between vectors and themselves are set to 0.0.\n     # This may not be the case due to floating point rounding errors.\n     if X is Y:\n-        distances = _fill_or_add_to_diagonal(distances, 0, xp=xp, add_value=False)\n+        _fill_diagonal(distances, 0, xp=xp)\n \n     if squared:\n         return distances\n@@ -1177,7 +1177,7 @@ def cosine_distances(X, Y=None):\n     if X is Y or Y is None:\n         # Ensure that distances between vectors and themselves are set to 0.0.\n         # This may not be the case due to floating point rounding errors.\n-        S = _fill_or_add_to_diagonal(S, 0.0, xp, add_value=False)\n+        _fill_diagonal(S, 0.0, xp)\n     return S\n \n \n@@ -1982,7 +1982,7 @@ def _parallel_pairwise(X, Y, func, n_jobs, **kwds):\n     if (X is Y or Y is None) and func is euclidean_distances:\n         # zeroing diagonal for euclidean norm.\n         # TODO: do it also for other norms.\n-        ret = _fill_or_add_to_diagonal(ret, 0, xp=xp, add_value=False)\n+        _fill_diagonal(ret, 0, xp=xp)\n \n     # Transform output back\n     return ret.T\ndiff --git a/sklearn/utils/_array_api.py b/sklearn/utils/_array_api.py\nindex 4d750b3ce159f..82a9d5b272c0f 100644\n--- a/sklearn/utils/_array_api.py\n+++ b/sklearn/utils/_array_api.py\n@@ -527,40 +527,80 @@ def _expit(X, xp=None):\n     return 1.0 / (1.0 + xp.exp(-X))\n \n \n-def _fill_or_add_to_diagonal(array, value, xp, add_value=True, wrap=False):\n-    \"\"\"Implementation to facilitate adding or assigning specified values to the\n-    diagonal of a 2-d array.\n-\n-    If ``add_value`` is `True` then the values will be added to the diagonal\n-    elements otherwise the values will be assigned to the diagonal elements.\n-    By default, ``add_value`` is set to `True. This is currently only\n-    supported for 2-d arrays.\n-\n-    The implementation is taken from the `numpy.fill_diagonal` function:\n-    https://github.com/numpy/numpy/blob/v2.0.0/numpy/lib/_index_tricks_impl.py#L799-L929\n-    \"\"\"\n+def _validate_diagonal_args(array, value, xp):\n+    \"\"\"Validate arguments to `_fill_diagonal`/`_add_to_diagonal`.\"\"\"\n     if array.ndim != 2:\n         raise ValueError(\n-            f\"array should be 2-d. Got array with shape {tuple(array.shape)}\"\n+            f\"`array` should be 2D. Got array with shape {tuple(array.shape)}\"\n         )\n \n     value = xp.asarray(value, dtype=array.dtype, device=device(array))\n-    end = None\n-    # Explicit, fast formula for the common case.  For 2-d arrays, we\n-    # accept rectangular ones.\n-    step = array.shape[1] + 1\n-    if not wrap:\n-        end = array.shape[1] * array.shape[1]\n+    if value.ndim not in [0, 1]:\n+        raise ValueError(\n+            \"`value` needs to be a scalar or a 1D array, \"\n+            f\"got a {value.ndim}D array instead.\"\n+        )\n+    min_rows_columns = min(array.shape)\n+    if value.ndim == 1 and value.shape[0] != min_rows_columns:\n+        raise ValueError(\n+            \"`value` needs to be a scalar or 1D array of the same length as the \"\n+            f\"diagonal of `array` ({min_rows_columns}). Got {value.shape[0]}\"\n+        )\n+\n+    return value, min_rows_columns\n+\n+\n+def _fill_diagonal(array, value, xp):\n+    \"\"\"Minimal implementation of `numpy.fill_diagonal`.\n+\n+    `wrap` is not supported (i.e. always False). `value` should be a scalar or\n+    1D of greater or equal length as the diagonal (i.e., `value` is never repeated\n+    when shorter).\n+\n+    Note `array` is altered in place.\n+    \"\"\"\n+    value, min_rows_columns = _validate_diagonal_args(array, value, xp)\n \n-    array_flat = xp.reshape(array, (-1,))\n-    if add_value:\n-        array_flat[:end:step] += value\n+    if _is_numpy_namespace(xp):\n+        xp.fill_diagonal(array, value, wrap=False)\n     else:\n-        array_flat[:end:step] = value\n-    # `array_flat` is not always a view on `array` (e.g. for certain array types that\n-    # were filled via parallel processing i.e., in `_parallel_pairwise`), thus we need\n-    # to return reshaped `array_flat`.\n-    return xp.reshape(array_flat, array.shape)\n+        # TODO: when array libraries support `reshape(copy)`, use\n+        # `reshape(array, (-1,), copy=False)`, then fill with `[:end:step]` (within\n+        # `try/except`). This is faster than for loop, when no copy needs to be\n+        # made within `reshape`. See #31445 for details.\n+        if value.ndim == 0:\n+            for i in range(min_rows_columns):\n+                array[i, i] = value\n+        else:\n+            for i in range(min_rows_columns):\n+                array[i, i] = value[i]\n+\n+\n+def _add_to_diagonal(array, value, xp):\n+    \"\"\"Add `value` to diagonal of `array`.\n+\n+    Related to `fill_diagonal`. `value` should be a scalar or\n+    1D of greater or equal length as the diagonal (i.e., `value` is never repeated\n+    when shorter).\n+\n+    Note `array` is altered in place.\n+    \"\"\"\n+    value, min_rows_columns = _validate_diagonal_args(array, value, xp)\n+\n+    if _is_numpy_namespace(xp):\n+        step = array.shape[1] + 1\n+        # Ensure we do not wrap\n+        end = array.shape[1] * array.shape[1]\n+        array.flat[:end:step] += value\n+        return\n+\n+    # TODO: when array libraries support `reshape(copy)`, use\n+    # `reshape(array, (-1,), copy=False)`, then fill with `[:end:step]` (within\n+    # `try/except`). This is faster than for loop, when no copy needs to be\n+    # made within `reshape`. See #31445 for details.\n+    value = xp.linalg.diagonal(array) + value\n+    for i in range(min_rows_columns):\n+        array[i, i] = value[i]\n \n \n def _is_xp_namespace(xp, name):\ndiff --git a/sklearn/utils/tests/test_array_api.py b/sklearn/utils/tests/test_array_api.py\nindex 5d35d86432f3c..ba0b63c6efd01 100644\n--- a/sklearn/utils/tests/test_array_api.py\n+++ b/sklearn/utils/tests/test_array_api.py\n@@ -9,13 +9,14 @@\n from sklearn._config import config_context\n from sklearn.base import BaseEstimator\n from sklearn.utils._array_api import (\n+    _add_to_diagonal,\n     _asarray_with_order,\n     _atol_for_type,\n     _average,\n     _convert_to_numpy,\n     _count_nonzero,\n     _estimator_with_converted_arrays,\n-    _fill_or_add_to_diagonal,\n+    _fill_diagonal,\n     _get_namespace_device_dtype_ids,\n     _is_numpy_namespace,\n     _isin,\n@@ -26,6 +27,7 @@\n     _nanmean,\n     _nanmin,\n     _ravel,\n+    _validate_diagonal_args,\n     device,\n     get_namespace,\n     get_namespace_and_device,\n@@ -576,21 +578,105 @@ def test_count_nonzero(\n         assert device(array_xp) == device(result)\n \n \n+@pytest.mark.parametrize(\n+    \"array, value, match\",\n+    [\n+        (numpy.array([1, 2, 3]), 1, \"`array` should be 2D\"),\n+        (numpy.array([[1, 2], [3, 4]]), numpy.array([1, 2, 3]), \"`value` needs to be\"),\n+        (numpy.array([[1, 2], [3, 4]]), [1, 2, 3], \"`value` needs to be\"),\n+        (\n+            numpy.array([[1, 2], [3, 4]]),\n+            numpy.array([[1, 2], [3, 4]]),\n+            \"`value` needs to be a\",\n+        ),\n+    ],\n+)\n+def test_validate_diagonal_args(array, value, match):\n+    \"\"\"Check `_validate_diagonal_args` raises the correct errors.\"\"\"\n+    xp = _array_api_for_tests(\"numpy\", None)\n+    with pytest.raises(ValueError, match=match):\n+        _validate_diagonal_args(array, value, xp)\n+\n+\n+@pytest.mark.parametrize(\"function\", [\"fill\", \"add\"])\n+@pytest.mark.parametrize(\"c_contiguity\", [True, False])\n+def test_fill_and_add_to_diagonal(c_contiguity, function):\n+    \"\"\"Check `_fill/add_to_diagonal` behaviour correct with numpy arrays.\"\"\"\n+    xp = _array_api_for_tests(\"numpy\", None)\n+    if c_contiguity:\n+        array = numpy.zeros((3, 4))\n+    else:\n+        array = numpy.zeros((3, 4)).T\n+    assert array.flags[\"C_CONTIGUOUS\"] == c_contiguity\n+\n+    if function == \"fill\":\n+        func = _fill_diagonal\n+    else:\n+        func = _add_to_diagonal\n+\n+    func(array, 1, xp)\n+    assert_allclose(array.diagonal(), numpy.ones((3,)))\n+\n+    func(array, [0, 1, 2], xp)\n+    if function == \"fill\":\n+        expected_diag = numpy.arange(3)\n+    else:\n+        expected_diag = numpy.ones((3,)) + numpy.arange(3)\n+    assert_allclose(array.diagonal(), expected_diag)\n+\n+    fill_array = numpy.array([11, 12, 13])\n+    func(array, fill_array, xp)\n+    if function == \"fill\":\n+        expected_diag = fill_array\n+    else:\n+        expected_diag = fill_array + numpy.arange(3) + numpy.ones((3,))\n+    assert_allclose(array.diagonal(), expected_diag)\n+\n+\n+@pytest.mark.parametrize(\"array\", [\"standard\", \"transposed\", \"non-contiguous\"])\n+@pytest.mark.parametrize(\n+    \"array_namespace, device_, dtype_name\",\n+    yield_namespace_device_dtype_combinations(),\n+    ids=_get_namespace_device_dtype_ids,\n+)\n+def test_fill_diagonal(array, array_namespace, device_, dtype_name):\n+    \"\"\"Check array API `_fill_diagonal` consistent with `numpy._fill_diagonal`.\"\"\"\n+    xp = _array_api_for_tests(array_namespace, device_)\n+    array_np = numpy.zeros((4, 5), dtype=dtype_name)\n+\n+    if array == \"transposed\":\n+        array_xp = xp.asarray(array_np.copy(), device=device_).T\n+        array_np = array_np.T\n+    elif array == \"non-contiguous\":\n+        array_xp = xp.asarray(array_np.copy(), device=device_)[::2, ::2]\n+        array_np = array_np[::2, ::2]\n+    else:\n+        array_xp = xp.asarray(array_np.copy(), device=device_)\n+\n+    numpy.fill_diagonal(array_np, val=1)\n+    with config_context(array_api_dispatch=True):\n+        _fill_diagonal(array_xp, value=1, xp=xp)\n+\n+    assert_array_equal(_convert_to_numpy(array_xp, xp=xp), array_np)\n+\n+\n @pytest.mark.parametrize(\n     \"array_namespace, device_, dtype_name\",\n     yield_namespace_device_dtype_combinations(),\n     ids=_get_namespace_device_dtype_ids,\n )\n-@pytest.mark.parametrize(\"wrap\", [True, False])\n-def test_fill_or_add_to_diagonal(array_namespace, device_, dtype_name, wrap):\n+def test_add_to_diagonal(array_namespace, device_, dtype_name):\n+    \"\"\"Check `_add_to_diagonal` consistent between array API xp and numpy namespace.\"\"\"\n     xp = _array_api_for_tests(array_namespace, device_)\n+    np_xp = _array_api_for_tests(\"numpy\", None)\n \n-    array_np = numpy.zeros((5, 4), dtype=dtype_name)\n+    array_np = numpy.zeros((3, 4), dtype=dtype_name)\n     array_xp = xp.asarray(array_np.copy(), device=device_)\n \n-    numpy.fill_diagonal(array_np, val=1, wrap=wrap)\n+    add_val = [1, 2, 3]\n+    _fill_diagonal(array_np, value=add_val, xp=np_xp)\n     with config_context(array_api_dispatch=True):\n-        _fill_or_add_to_diagonal(array_xp, value=1, xp=xp, add_value=False, wrap=wrap)\n+        _fill_diagonal(array_xp, value=add_val, xp=xp)\n \n     assert_array_equal(_convert_to_numpy(array_xp, xp=xp), array_np)\n \n",
  "fail_to_pass": [
    "test_validate_diagonal_args",
    "test_fill_and_add_to_diagonal",
    "test_fill_diagonal",
    "test_add_to_diagonal"
  ],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/decomposition/_base.py",
    "sklearn/metrics/pairwise.py",
    "sklearn/utils/_array_api.py",
    "sklearn/utils/tests/test_array_api.py"
  ],
  "difficulty": "hard",
  "created_at": "2025-05-28T10:21:52Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/31445",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/pull/29822"
}