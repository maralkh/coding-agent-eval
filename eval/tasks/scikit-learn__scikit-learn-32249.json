{
  "id": "scikit-learn__scikit-learn-32249",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "4fd34545e517d164881126ce539aa8bfabae86d2",
  "issue_number": 26024,
  "issue_title": "Make more of the \"tools\" of scikit-learn Array API compatible",
  "issue_body": "\ud83d\udea8 \ud83d\udea7 This issue requires a bit of patience and experience to contribute to \ud83d\udea7 \ud83d\udea8 \r\n\r\n- Original issue introducing array API in scikit-learn: #22352\r\n- array API official doc/spec: https://data-apis.org/array-api/\r\n- scikit-learn doc: https://scikit-learn.org/dev/modules/array_api.html\r\n\r\nPlease mention this issue when you create a PR, but please don't write \"closes #26024\" or \"fixes #26024\".\r\n\r\nscikit-learn contains lots of useful tools, in addition to the many estimators it has. For example [metrics](https://scikit-learn.org/stable/modules/classes.html#sklearn-metrics-metrics), [pipelines](https://scikit-learn.org/stable/modules/classes.html#module-sklearn.pipeline), [pre-processing](https://scikit-learn.org/stable/modules/classes.html#module-sklearn.preprocessing) and [mode selection](https://scikit-learn.org/stable/modules/classes.html#module-sklearn.model_selection). These are useful to and used by people who do not necessarily use an estimator from scikit-learn. This is great.\r\n\r\nThe fact that many users install scikit-learn \"just\" to use `train_test_split` is a testament to how useful it is to provide easy to use tools that do the right(!) thing. Instead of everyone implementing them from scratch because it is \"easy\" and making mistakes along the way.\r\n\r\nIn this issue I'd like to collect and track work related to making it easier to use all these \"tools\" from scikit-learn even if you are not using Numpy arrays for your data. In particular thanks to the Array API standard it should be \"not too much work\" to make things usable with data that is in an array that conforms to the Array API standard.\r\n\r\nThere is work in #25956 and #22554 which adds the basic infrastructure needed to use \"array API arrays\".\r\n\r\nThe goal of this issue is to make code like the following work:\r\n```python\r\n>>> from sklearn.preprocessing import MinMaxScaler\r\n>>> from sklearn import config_context\r\n>>> from sklearn.datasets import make_classification\r\n>>> import torch\r\n>>> X_np, y_np = make_classification(random_state=0)\r\n>>> X_torch = torch.asarray(X_np, device=\"cuda\", dtype=torch.float32)\r\n>>> y_torch = torch.asarray(y_np, device=\"cuda\", dtype=torch.float32)\r\n\r\n>>> with config_context(array_api_dispatch=True):\r\n...     # For example using MinMaxScaler on PyTorch tensors\r\n...     scale = MinMaxScaler()\r\n...     X_trans = scale.fit_transform(X_torch, y_torch)\r\n...     assert type(X_trans) == type(X_torch)\r\n...     assert X_trans.device == X_torch.device\r\n```\r\n\r\nThe first step (or maybe part of the first) is to check which of them already \"just work\". After that is done we can start the work (one PR per class/function) making changes.\r\n\r\n\r\n## Guidelines for testing\r\n\r\nGeneral comment: most of the time when we add array API support to a function in scikit-learn, we do not touch the existing (numpy-only) tests to make sure that the PR does not change the default behavior of scikit-learn on traditional inputs when array API is not enabled.\r\n\r\nIn the case of an estimator, it can be enough to add the `array_api_support=True` estimator tag in a method named `__sklearn_tags__`. For metric functions, just register it in the `array_api_metric_checkers` in `sklearn/metrics/tests/test_common.py` to include it in the common test.\r\n\r\nFor other kinds of functions not covered by existing common tests, or when the array API support depends heavily on non-default values, it might be required to add one or more new test functions to the related module-level test file. The general testing scheme is the following:\r\n\r\n- generate some random test data with numpy or `sklearn.datasets.make_*`;\r\n- call the function once on the numpy inputs without enabling array API dispatch;\r\n- convert the inputs to a namespace / device combo passed as parameter to the test;\r\n- call the function with array API dispatching enabled (under a `with sklearn.config_context(array_api_dispatch=True)` block\r\n- check that the results are on the same namespace and device as the input\r\n- convert back the output to a numpy array using `_convert_to_numpy`\r\n- compare the original / reference numpy results and the `xp` computation results converted back to numpy using `assert_allclose` or similar.\r\n\r\nThose tests should have `array_api` somewhere in their name to makes sure that we can run all the array API compliance tests with a keyword search in the pytest command line, e.g.:\r\n\r\n```\r\npytest -k array_api sklearn/some/subpackage\r\n```\r\n\r\nIn particular, for cost reasons, our CUDA GPU CI only runs `pytest -k array_api sklearn`. So it's very important to respect this naming conventions, otherwise we will not tests all what we are supposed to test on CUDA.\r\n\r\nMore generally, look at merged array API pull requests to see how testing is typically handled.",
  "pr_number": 32249,
  "pr_title": "Add array API support to `precision_recall_curve`",
  "gold_patch": "diff --git a/doc/modules/array_api.rst b/doc/modules/array_api.rst\nindex a14da1a986231..aa9225dfa6dba 100644\n--- a/doc/modules/array_api.rst\n+++ b/doc/modules/array_api.rst\n@@ -174,6 +174,7 @@ Metrics\n - :func:`sklearn.metrics.pairwise.rbf_kernel` (see :ref:`device_support_for_float64`)\n - :func:`sklearn.metrics.pairwise.sigmoid_kernel`\n - :func:`sklearn.metrics.precision_score`\n+- :func:`sklearn.metrics.precision_recall_curve`\n - :func:`sklearn.metrics.precision_recall_fscore_support`\n - :func:`sklearn.metrics.r2_score`\n - :func:`sklearn.metrics.recall_score`\ndiff --git a/doc/whats_new/upcoming_changes/array-api/32249.feature.rst b/doc/whats_new/upcoming_changes/array-api/32249.feature.rst\nnew file mode 100644\nindex 0000000000000..f8102a540328f\n--- /dev/null\n+++ b/doc/whats_new/upcoming_changes/array-api/32249.feature.rst\n@@ -0,0 +1,3 @@\n+- :func:`sklearn.metrics.precision_recall_curve` now supports array API compatible\n+  inputs.\n+  By :user:`Lucy Liu <lucyleeow>`\ndiff --git a/sklearn/metrics/_ranking.py b/sklearn/metrics/_ranking.py\nindex f9584772fa85c..9ed5169e5b888 100644\n--- a/sklearn/metrics/_ranking.py\n+++ b/sklearn/metrics/_ranking.py\n@@ -1031,19 +1031,24 @@ def precision_recall_curve(\n     >>> thresholds\n     array([0.1 , 0.35, 0.4 , 0.8 ])\n     \"\"\"\n+    xp, _, device = get_namespace_and_device(y_true, y_score)\n     fps, tps, thresholds = _binary_clf_curve(\n         y_true, y_score, pos_label=pos_label, sample_weight=sample_weight\n     )\n \n-    if drop_intermediate and len(fps) > 2:\n+    if drop_intermediate and fps.shape[0] > 2:\n         # Drop thresholds corresponding to points where true positives (tps)\n         # do not change from the previous or subsequent point. This will keep\n         # only the first and last point for each tps value. All points\n         # with the same tps value have the same recall and thus x coordinate.\n         # They appear as a vertical line on the plot.\n-        optimal_idxs = np.where(\n-            np.concatenate(\n-                [[True], np.logical_or(np.diff(tps[:-1]), np.diff(tps[1:])), [True]]\n+        optimal_idxs = xp.where(\n+            xp.concat(\n+                [\n+                    xp.asarray([True], device=device),\n+                    xp.logical_or(xp.diff(tps[:-1]), xp.diff(tps[1:])),\n+                    xp.asarray([True], device=device),\n+                ]\n             )\n         )[0]\n         fps = fps[optimal_idxs]\n@@ -1053,8 +1058,7 @@ def precision_recall_curve(\n     ps = tps + fps\n     # Initialize the result array with zeros to make sure that precision[ps == 0]\n     # does not contain uninitialized values.\n-    precision = np.zeros_like(tps)\n-    np.divide(tps, ps, out=precision, where=(ps != 0))\n+    precision = xp.where(ps != 0, xp.divide(tps, ps), 0.0)\n \n     # When no positive label in y_true, recall is set to 1 for all thresholds\n     # tps[-1] == 0 <=> y_true == all negative labels\n@@ -1063,13 +1067,16 @@ def precision_recall_curve(\n             \"No positive class found in y_true, \"\n             \"recall is set to one for all thresholds.\"\n         )\n-        recall = np.ones_like(tps)\n+        recall = xp.full(tps.shape, 1.0)\n     else:\n         recall = tps / tps[-1]\n \n     # reverse the outputs so recall is decreasing\n-    sl = slice(None, None, -1)\n-    return np.hstack((precision[sl], 1)), np.hstack((recall[sl], 0)), thresholds[sl]\n+    return (\n+        xp.concat((xp.flip(precision), xp.asarray([1.0], device=device))),\n+        xp.concat((xp.flip(recall), xp.asarray([0.0], device=device))),\n+        xp.flip(thresholds),\n+    )\n \n \n @validate_params(\ndiff --git a/sklearn/metrics/tests/test_common.py b/sklearn/metrics/tests/test_common.py\nindex 250fde9948f62..95726d0497c79 100644\n--- a/sklearn/metrics/tests/test_common.py\n+++ b/sklearn/metrics/tests/test_common.py\n@@ -1955,42 +1955,49 @@ def check_array_api_metric(\n         # Exception type may need to be updated in the future for other libraries.\n         numpy_as_array_works = False\n \n+    def _check_metric_matches(metric_a, metric_b, convert_a=False):\n+        if convert_a:\n+            metric_a = _convert_to_numpy(xp.asarray(metric_a), xp)\n+        assert_allclose(metric_a, metric_b, atol=_atol_for_type(dtype_name))\n+\n+    def _check_each_metric_matches(metric_a, metric_b, convert_a=False):\n+        for metric_a_val, metric_b_val in zip(metric_a, metric_b):\n+            _check_metric_matches(metric_a_val, metric_b_val, convert_a=convert_a)\n+\n     if numpy_as_array_works:\n         metric_xp = metric(a_xp, b_xp, **metric_kwargs)\n-        assert_allclose(\n-            metric_xp,\n-            metric_np,\n-            atol=_atol_for_type(dtype_name),\n-        )\n-        metric_xp_mixed_1 = metric(a_np, b_xp, **metric_kwargs)\n-        assert_allclose(\n-            metric_xp_mixed_1,\n-            metric_np,\n-            atol=_atol_for_type(dtype_name),\n-        )\n-        metric_xp_mixed_2 = metric(a_xp, b_np, **metric_kwargs)\n-        assert_allclose(\n-            metric_xp_mixed_2,\n-            metric_np,\n-            atol=_atol_for_type(dtype_name),\n-        )\n+\n+        # Handle cases where multiple return values are not of the same shape,\n+        # e.g. precision_recall_curve:\n+        if (\n+            isinstance(metric_np, tuple)\n+            and len(set([metric_val.shape for metric_val in metric_np])) > 1\n+        ):\n+            _check_each_metric_matches(metric_xp, metric_np)\n+\n+            metric_xp_mixed_1 = metric(a_np, b_xp, **metric_kwargs)\n+            _check_each_metric_matches(metric_xp_mixed_1, metric_np)\n+\n+            metric_xp_mixed_2 = metric(a_xp, b_np, **metric_kwargs)\n+            _check_each_metric_matches(metric_xp_mixed_2, metric_np)\n+\n+        else:\n+            _check_metric_matches(metric_xp, metric_np)\n+\n+            metric_xp_mixed_1 = metric(a_np, b_xp, **metric_kwargs)\n+            _check_metric_matches(metric_xp_mixed_1, metric_np)\n+\n+            metric_xp_mixed_2 = metric(a_xp, b_np, **metric_kwargs)\n+            _check_metric_matches(metric_xp_mixed_2, metric_np)\n \n     with config_context(array_api_dispatch=True):\n         metric_xp = metric(a_xp, b_xp, **metric_kwargs)\n \n-        def _check_metric_matches(xp_val, np_val):\n-            assert_allclose(\n-                _convert_to_numpy(xp.asarray(xp_val), xp),\n-                np_val,\n-                atol=_atol_for_type(dtype_name),\n-            )\n-\n         # Handle cases where there are multiple return values, e.g. roc_curve:\n         if isinstance(metric_xp, tuple):\n-            for metric_xp_val, metric_np_val in zip(metric_xp, metric_np):\n-                _check_metric_matches(metric_xp_val, metric_np_val)\n+            _check_each_metric_matches(metric_xp, metric_np, convert_a=True)\n         else:\n-            _check_metric_matches(metric_xp, metric_np)\n+            _check_metric_matches(metric_xp, metric_np, convert_a=True)\n \n \n def check_array_api_binary_classification_metric(\n@@ -2256,6 +2263,7 @@ def check_array_api_metric_pairwise(metric, array_namespace, device, dtype_name)\n         check_array_api_multiclass_classification_metric,\n         check_array_api_multilabel_classification_metric,\n     ],\n+    precision_recall_curve: [check_array_api_binary_classification_metric],\n     recall_score: [\n         check_array_api_binary_classification_metric,\n         check_array_api_multiclass_classification_metric,\n",
  "fail_to_pass": [],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/metrics/_ranking.py",
    "sklearn/metrics/tests/test_common.py"
  ],
  "difficulty": "hard",
  "created_at": "2025-09-22T10:54:28Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/32249",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/issues/26024"
}