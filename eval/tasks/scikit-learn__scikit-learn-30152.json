{
  "id": "scikit-learn__scikit-learn-30152",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "0d98d1461ed1ea59b2e8af1649250286ce5cc8f5",
  "issue_number": 1234,
  "issue_title": "MRG fix bincount mess I made in kmeans.",
  "issue_body": "This should clean up the stuff I pushed earlier.\ncc @ogrisel @gaelvaroquaux Could you have a brief look? What I pushed earlier is buggy but I didn't dare push again after so many failed fixes.\n",
  "pr_number": 30152,
  "pr_title": "MAINT rename `base_estimator` in `_BaseChain` subclasses",
  "gold_patch": "diff --git a/doc/whats_new/upcoming_changes/sklearn.multioutput/30152.enhancement.rst b/doc/whats_new/upcoming_changes/sklearn.multioutput/30152.enhancement.rst\nnew file mode 100644\nindex 0000000000000..3bc2ae2f6ced4\n--- /dev/null\n+++ b/doc/whats_new/upcoming_changes/sklearn.multioutput/30152.enhancement.rst\n@@ -0,0 +1,3 @@\n+- The parameter `base_estimator` has been deprecated in favour of `estimator` for\n+  :class:`multioutput.RegressorChain` and :class:`multioutput.ClassifierChain`.\n+  By :user:`Success Moses <SuccessMoses>` and :user:`dikraMasrour <dikra_masrour>`\ndiff --git a/sklearn/multioutput.py b/sklearn/multioutput.py\nindex 38b6eb4a7e0ec..b71fc082eb934 100644\n--- a/sklearn/multioutput.py\n+++ b/sklearn/multioutput.py\n@@ -9,6 +9,7 @@\n # SPDX-License-Identifier: BSD-3-Clause\n \n \n+import warnings\n from abc import ABCMeta, abstractmethod\n from numbers import Integral\n \n@@ -26,7 +27,11 @@\n )\n from .model_selection import cross_val_predict\n from .utils import Bunch, check_random_state, get_tags\n-from .utils._param_validation import HasMethods, StrOptions\n+from .utils._param_validation import (\n+    HasMethods,\n+    Hidden,\n+    StrOptions,\n+)\n from .utils._response import _get_response_values\n from .utils._user_interface import _print_elapsed_time\n from .utils.metadata_routing import (\n@@ -628,7 +633,7 @@ def _available_if_base_estimator_has(attr):\n     \"\"\"\n \n     def _check(self):\n-        return hasattr(self.base_estimator, attr) or all(\n+        return hasattr(self._get_estimator(), attr) or all(\n             hasattr(est, attr) for est in self.estimators_\n         )\n \n@@ -637,22 +642,61 @@ def _check(self):\n \n class _BaseChain(BaseEstimator, metaclass=ABCMeta):\n     _parameter_constraints: dict = {\n-        \"base_estimator\": [HasMethods([\"fit\", \"predict\"])],\n+        \"base_estimator\": [\n+            HasMethods([\"fit\", \"predict\"]),\n+            StrOptions({\"deprecated\"}),\n+        ],\n+        \"estimator\": [\n+            HasMethods([\"fit\", \"predict\"]),\n+            Hidden(None),\n+        ],\n         \"order\": [\"array-like\", StrOptions({\"random\"}), None],\n         \"cv\": [\"cv_object\", StrOptions({\"prefit\"})],\n         \"random_state\": [\"random_state\"],\n         \"verbose\": [\"boolean\"],\n     }\n \n+    # TODO(1.9): Remove base_estimator\n     def __init__(\n-        self, base_estimator, *, order=None, cv=None, random_state=None, verbose=False\n+        self,\n+        estimator=None,\n+        *,\n+        order=None,\n+        cv=None,\n+        random_state=None,\n+        verbose=False,\n+        base_estimator=\"deprecated\",\n     ):\n+        self.estimator = estimator\n         self.base_estimator = base_estimator\n         self.order = order\n         self.cv = cv\n         self.random_state = random_state\n         self.verbose = verbose\n \n+    # TODO(1.8): This is a temporary getter method to validate input wrt deprecation.\n+    # It was only included to avoid relying on the presence of self.estimator_\n+    def _get_estimator(self):\n+        \"\"\"Get and validate estimator.\"\"\"\n+\n+        if self.estimator is not None and (self.base_estimator != \"deprecated\"):\n+            raise ValueError(\n+                \"Both `estimator` and `base_estimator` are provided. You should only\"\n+                \" pass `estimator`. `base_estimator` as a parameter is deprecated in\"\n+                \" version 1.7, and will be removed in version 1.9.\"\n+            )\n+\n+        if self.base_estimator != \"deprecated\":\n+\n+            warning_msg = (\n+                \"`base_estimator` as an argument was deprecated in 1.7 and will be\"\n+                \" removed in 1.9. Use `estimator` instead.\"\n+            )\n+            warnings.warn(warning_msg, FutureWarning)\n+            return self.base_estimator\n+        else:\n+            return self.estimator\n+\n     def _log_message(self, *, estimator_idx, n_estimators, processing_msg):\n         if not self.verbose:\n             return None\n@@ -735,7 +779,7 @@ def fit(self, X, Y, **fit_params):\n         elif sorted(self.order_) != list(range(Y.shape[1])):\n             raise ValueError(\"invalid order\")\n \n-        self.estimators_ = [clone(self.base_estimator) for _ in range(Y.shape[1])]\n+        self.estimators_ = [clone(self._get_estimator()) for _ in range(Y.shape[1])]\n \n         if self.cv is None:\n             Y_pred_chain = Y[:, self.order_]\n@@ -774,7 +818,7 @@ def fit(self, X, Y, **fit_params):\n \n         if hasattr(self, \"chain_method\"):\n             chain_method = _check_response_method(\n-                self.base_estimator,\n+                self._get_estimator(),\n                 self.chain_method,\n             ).__name__\n             self.chain_method_ = chain_method\n@@ -799,7 +843,7 @@ def fit(self, X, Y, **fit_params):\n             if self.cv is not None and chain_idx < len(self.estimators_) - 1:\n                 col_idx = X.shape[1] + chain_idx\n                 cv_result = cross_val_predict(\n-                    self.base_estimator,\n+                    self._get_estimator(),\n                     X_aug[:, :col_idx],\n                     y=y,\n                     cv=self.cv,\n@@ -832,7 +876,7 @@ def predict(self, X):\n \n     def __sklearn_tags__(self):\n         tags = super().__sklearn_tags__()\n-        tags.input_tags.sparse = get_tags(self.base_estimator).input_tags.sparse\n+        tags.input_tags.sparse = get_tags(self._get_estimator()).input_tags.sparse\n         return tags\n \n \n@@ -854,7 +898,7 @@ class ClassifierChain(MetaEstimatorMixin, ClassifierMixin, _BaseChain):\n \n     Parameters\n     ----------\n-    base_estimator : estimator\n+    estimator : estimator\n         The base estimator from which the classifier chain is built.\n \n     order : array-like of shape (n_outputs,) or 'random', default=None\n@@ -911,6 +955,13 @@ class ClassifierChain(MetaEstimatorMixin, ClassifierMixin, _BaseChain):\n \n         .. versionadded:: 1.2\n \n+    base_estimator : estimator, default=\"deprecated\"\n+        Use `estimator` instead.\n+\n+        .. deprecated:: 1.7\n+            `base_estimator` is deprecated and will be removed in 1.9.\n+            Use `estimator` instead.\n+\n     Attributes\n     ----------\n     classes_ : list\n@@ -985,22 +1036,25 @@ class labels for each estimator in the chain.\n         ],\n     }\n \n+    # TODO(1.9): Remove base_estimator from __init__\n     def __init__(\n         self,\n-        base_estimator,\n+        estimator=None,\n         *,\n         order=None,\n         cv=None,\n         chain_method=\"predict\",\n         random_state=None,\n         verbose=False,\n+        base_estimator=\"deprecated\",\n     ):\n         super().__init__(\n-            base_estimator,\n+            estimator,\n             order=order,\n             cv=cv,\n             random_state=random_state,\n             verbose=verbose,\n+            base_estimator=base_estimator,\n         )\n         self.chain_method = chain_method\n \n@@ -1100,8 +1154,9 @@ def get_metadata_routing(self):\n             A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n             routing information.\n         \"\"\"\n+\n         router = MetadataRouter(owner=self.__class__.__name__).add(\n-            estimator=self.base_estimator,\n+            estimator=self._get_estimator(),\n             method_mapping=MethodMapping().add(caller=\"fit\", callee=\"fit\"),\n         )\n         return router\n@@ -1128,7 +1183,7 @@ class RegressorChain(MetaEstimatorMixin, RegressorMixin, _BaseChain):\n \n     Parameters\n     ----------\n-    base_estimator : estimator\n+    estimator : estimator\n         The base estimator from which the regressor chain is built.\n \n     order : array-like of shape (n_outputs,) or 'random', default=None\n@@ -1172,6 +1227,13 @@ class RegressorChain(MetaEstimatorMixin, RegressorMixin, _BaseChain):\n \n         .. versionadded:: 1.2\n \n+    base_estimator : estimator, default=\"deprecated\"\n+        Use `estimator` instead.\n+\n+        .. deprecated:: 1.7\n+            `base_estimator` is deprecated and will be removed in 1.9.\n+            Use `estimator` instead.\n+\n     Attributes\n     ----------\n     estimators_ : list\n@@ -1204,7 +1266,7 @@ class RegressorChain(MetaEstimatorMixin, RegressorMixin, _BaseChain):\n     >>> from sklearn.linear_model import LogisticRegression\n     >>> logreg = LogisticRegression(solver='lbfgs')\n     >>> X, Y = [[1, 0], [0, 1], [1, 1]], [[0, 2], [1, 1], [2, 0]]\n-    >>> chain = RegressorChain(base_estimator=logreg, order=[0, 1]).fit(X, Y)\n+    >>> chain = RegressorChain(logreg, order=[0, 1]).fit(X, Y)\n     >>> chain.predict(X)\n     array([[0., 2.],\n            [1., 1.],\n@@ -1254,8 +1316,9 @@ def get_metadata_routing(self):\n             A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n             routing information.\n         \"\"\"\n+\n         router = MetadataRouter(owner=self.__class__.__name__).add(\n-            estimator=self.base_estimator,\n+            estimator=self._get_estimator(),\n             method_mapping=MethodMapping().add(caller=\"fit\", callee=\"fit\"),\n         )\n         return router\ndiff --git a/sklearn/tests/test_metaestimators_metadata_routing.py b/sklearn/tests/test_metaestimators_metadata_routing.py\nindex b733f4d119f5e..6947c14ff5e59 100644\n--- a/sklearn/tests/test_metaestimators_metadata_routing.py\n+++ b/sklearn/tests/test_metaestimators_metadata_routing.py\n@@ -119,7 +119,7 @@\n     },\n     {\n         \"metaestimator\": ClassifierChain,\n-        \"estimator_name\": \"base_estimator\",\n+        \"estimator_name\": \"estimator\",\n         \"estimator\": \"classifier\",\n         \"X\": X,\n         \"y\": y_multi,\n@@ -127,7 +127,7 @@\n     },\n     {\n         \"metaestimator\": RegressorChain,\n-        \"estimator_name\": \"base_estimator\",\n+        \"estimator_name\": \"estimator\",\n         \"estimator\": \"regressor\",\n         \"X\": X,\n         \"y\": y_multi,\ndiff --git a/sklearn/tests/test_multioutput.py b/sklearn/tests/test_multioutput.py\nindex 4b055169776d0..c5bff07573337 100644\n--- a/sklearn/tests/test_multioutput.py\n+++ b/sklearn/tests/test_multioutput.py\n@@ -864,3 +864,19 @@ def test_multioutput_regressor_has_partial_fit():\n     msg = \"This 'MultiOutputRegressor' has no attribute 'partial_fit'\"\n     with pytest.raises(AttributeError, match=msg):\n         getattr(est, \"partial_fit\")\n+\n+\n+# TODO(1.9):  remove when deprecated `base_estimator` is removed\n+@pytest.mark.parametrize(\"Estimator\", [ClassifierChain, RegressorChain])\n+def test_base_estimator_deprecation(Estimator):\n+    \"\"\"Check that we warn about the deprecation of `base_estimator`.\"\"\"\n+    X = np.array([[1, 2], [3, 4]])\n+    y = np.array([[1, 0], [0, 1]])\n+\n+    estimator = LogisticRegression()\n+\n+    with pytest.warns(FutureWarning):\n+        Estimator(base_estimator=estimator).fit(X, y)\n+\n+    with pytest.raises(ValueError):\n+        Estimator(base_estimator=estimator, estimator=estimator).fit(X, y)\ndiff --git a/sklearn/utils/_test_common/instance_generator.py b/sklearn/utils/_test_common/instance_generator.py\nindex a29748183d7ac..3a16d4b02cacc 100644\n--- a/sklearn/utils/_test_common/instance_generator.py\n+++ b/sklearn/utils/_test_common/instance_generator.py\n@@ -197,7 +197,7 @@\n     BisectingKMeans: dict(n_init=2, n_clusters=2, max_iter=5),\n     CalibratedClassifierCV: dict(estimator=LogisticRegression(C=1), cv=3),\n     CCA: dict(n_components=1, max_iter=5),\n-    ClassifierChain: dict(base_estimator=LogisticRegression(C=1), cv=3),\n+    ClassifierChain: dict(estimator=LogisticRegression(C=1), cv=3),\n     ColumnTransformer: dict(transformers=[(\"trans1\", StandardScaler(), [0, 1])]),\n     DictionaryLearning: dict(max_iter=20, transform_algorithm=\"lasso_lars\"),\n     # the default strategy prior would output constant predictions and fail\n@@ -429,7 +429,7 @@\n     # For common tests, we can enforce using `LinearRegression` that\n     # is the default estimator in `RANSACRegressor` instead of `Ridge`.\n     RANSACRegressor: dict(estimator=LinearRegression(), max_trials=10),\n-    RegressorChain: dict(base_estimator=Ridge(), cv=3),\n+    RegressorChain: dict(estimator=Ridge(), cv=3),\n     RFECV: dict(estimator=LogisticRegression(C=1), cv=3),\n     RFE: dict(estimator=LogisticRegression(C=1)),\n     # be tolerant of noisy datasets (not actually speed)\n",
  "fail_to_pass": [
    "test_base_estimator_deprecation"
  ],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/multioutput.py",
    "sklearn/tests/test_metaestimators_metadata_routing.py",
    "sklearn/tests/test_multioutput.py",
    "sklearn/utils/_test_common/instance_generator.py"
  ],
  "difficulty": "hard",
  "created_at": "2024-10-25T12:16:55Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/30152",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/pull/1234"
}