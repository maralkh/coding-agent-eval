{
  "id": "scikit-learn__scikit-learn-32540",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "f498ff2f1b9a8c0602823eef19882d970c50145d",
  "issue_number": 32478,
  "issue_title": "StratifiedGroupKFold(shuffle=True) breaks group-index mapping, leading to incorrect (effectively random) group assignments per fold",
  "issue_body": "### Describe the bug\n\nWhen `StratifiedGroupKFold` is instantiated with `shuffle=True`, the implementation shuffles the `y_counts_per_group` array **without** updating the associated `groups_inv` mapping. This decouples the internal row index used for each group\u2019s class-count vector from the actual group IDs of the samples. The greedy assignment that follows then optimizes fold balance using indices of the **shuffled** `y_counts_per_group`, but later, when building `test_indices`, membership is checked against the **unshuffled** `groups_inv`. As a result, the reported groups in each test split correspond to a random permutation of the groups the greedy algorithm actually balanced, and the intended stratification by `y` is lost; in effect, with `shuffle=True` the splitter behaves like a `GroupKFold` (non-stratified) rather than a stratified group split.\n\n### Steps/Code to Reproduce\n\n```python\nimport numpy as np\nfrom sklearn.model_selection import StratifiedGroupKFold\n\nX = np.ones((18, 2))\ny = np.array([0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1])\ngroups = np.array([1, 1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5, 6, 6, 7, 7, 8, 8])\n\nsgkf = StratifiedGroupKFold(n_splits=3, shuffle=True, random_state=42)\nfor i, (_, test_idx) in enumerate(sgkf.split(X, y, groups)):\n    print(\n        f\"Fold {i}: groups {np.unique(groups[test_idx])}, \"\n        f\"positive class ratio {y[test_idx].mean():.3f}\"\n    )\n\nsgkf = StratifiedGroupKFold(n_splits=3, shuffle=False, random_state=None)\nfor i, (_, test_idx) in enumerate(sgkf.split(X, y, groups)):\n    print(\n        f\"Fold {i}: groups {np.unique(groups[test_idx])}, \"\n        f\"positive class ratio {y[test_idx].mean():.3f}\"\n    )\n```\nResults with `shuffle=True` and `random_state=42`:\nFold 0: groups `[4 6]`, positive class ratio `0.667`\nFold 1: groups `[2 5 7]`, positive class ratio `0.250`\nFold 2: groups `[1 3 8]`, positive class ratio `0.286`\n\nResults without shuffle:\nFold 0: groups `[5 8]`, positive class ratio `0.333`\nFold 1: groups `[3 4 6]`, positive class ratio `0.333`\nFold 2: groups `[1 2 7]`, positive class ratio `0.333`\n\n### Expected Results\n\nWith `shuffle=True`, the `rng.shuffle(y_counts_per_group)` happens **before** computing per-group class-count variances and the subsequent stable sort. Because a stable sort is used, the shuffle should act **only as a tie-breaker among groups with exactly the same variance**; it should not reorder groups that have different variances. Crucially, the permutation applied to `y_counts_per_group` must be mirrored in `groups_inv` so that the mapping from matrix rows to true group IDs remains consistent. Under this condition, the groups reported in each test fold will be exactly those selected by the greedy algorithm, and stratification quality should be comparable to the `shuffle=False` case.\nFor the provided example (overall positive rate = 6/18 = 0.333), a perfectly stratified solution exists (as shown by the `shuffle=False` run yielding `0.333, 0.333, 0.333`), and with `shuffle=True` we would expect a (possibly different) grouping but still ~`0.333` per fold.\n\n\n### Actual Results\n\nWith `shuffle=True` and `random_state=42`, the reported folds are:\nFold 0: groups `[4 6]`, positive class ratio `0.667`\nFold 1: groups `[2 5 7]`, positive class ratio `0.250`\nFold 2: groups `[1 3 8]`, positive class ratio `0.286`\n\nThese deviations indicate that stratification is not respected. The reason is that `y_counts_per_group` is shuffled **without** remapping `groups_inv`. As a result, even though the stable sort limits the shuffle\u2019s effect to tie-breaking among equal-variance groups, the greedy assignment then operates on a **permuted** matrix whose row indices no longer correspond to the true group IDs. When building `test_indices`, membership is checked against the obsolete `groups_inv`, producing folds whose group sets are, in practice, a random permutation of those intended by the greedy algorithm; that is, in practice, the splitter behaves like a non-stratified `GroupKFold`.\n\n### Versions\n\n```shell\nSystem:\n    python: 3.12.11 | packaged by Anaconda, Inc. | (main, Jun  5 2025, 13:09:17) [GCC 11.2.0]\nexecutable: /home/pfolch/anaconda3/envs/ecos/bin/python\n   machine: Linux-6.6.87.2-microsoft-standard-WSL2-x86_64-with-glibc2.39\n\nPython dependencies:\n      sklearn: 1.7.2\n          pip: 25.2\n   setuptools: 80.9.0\n        numpy: 2.2.6\n        scipy: 1.16.2\n       Cython: None\n       pandas: 2.3.2\n   matplotlib: 3.10.6\n       joblib: 1.5.2\nthreadpoolctl: 3.6.0\n\nBuilt with OpenMP: True\n\nthreadpoolctl info:\n       user_api: blas\n   internal_api: openblas\n    num_threads: 24\n         prefix: libscipy_openblas\n       filepath: /home/pfolch/anaconda3/envs/ecos/lib/python3.12/site-packages/numpy.libs/libscipy_openblas64_-56d6093b.so\n        version: 0.3.29\nthreading_layer: pthreads\n   architecture: SkylakeX\n\n       user_api: openmp\n   internal_api: openmp\n    num_threads: 12\n         prefix: libgomp\n       filepath: /home/pfolch/anaconda3/envs/ecos/lib/python3.12/site-packages/torch/lib/libgomp.so.1\n        version: None\n\n       user_api: blas\n   internal_api: openblas\n    num_threads: 24\n         prefix: libscipy_openblas\n       filepath: /home/pfolch/anaconda3/envs/ecos/lib/python3.12/site-packages/scipy.libs/libscipy_openblas-b75cc656.so\n        version: 0.3.29.dev\nthreading_layer: pthreads\n   architecture: SkylakeX\n\n       user_api: openmp\n   internal_api: openmp\n    num_threads: 24\n         prefix: libgomp\n       filepath: /home/pfolch/anaconda3/envs/ecos/lib/python3.12/site-packages/scikit_learn.libs/libgomp-a34b3233.so.1.0.0\n        version: None\n```",
  "pr_number": 32540,
  "pr_title": "FIX stratification in StratifiedGroupKFold when shuffle=True",
  "gold_patch": "diff --git a/doc/whats_new/upcoming_changes/sklearn.model_selection/32540.fix.rst b/doc/whats_new/upcoming_changes/sklearn.model_selection/32540.fix.rst\nnew file mode 100644\nindex 0000000000000..ec15ecccee161\n--- /dev/null\n+++ b/doc/whats_new/upcoming_changes/sklearn.model_selection/32540.fix.rst\n@@ -0,0 +1,3 @@\n+- Fix shuffle behaviour in :class:`model_selection.StratifiedGroupKFold`. Now\n+  stratification among folds is also preserved when `shuffle=True`.\n+  By :user:`Pau Folch <pfolch>`.\ndiff --git a/sklearn/model_selection/_split.py b/sklearn/model_selection/_split.py\nindex 1e434962b4672..5bbbd3a745d60 100644\n--- a/sklearn/model_selection/_split.py\n+++ b/sklearn/model_selection/_split.py\n@@ -1052,7 +1052,12 @@ def _iter_test_indices(self, X, y, groups):\n         groups_per_fold = defaultdict(set)\n \n         if self.shuffle:\n-            rng.shuffle(y_counts_per_group)\n+            perm = np.arange(len(groups_cnt))\n+            rng.shuffle(perm)\n+            y_counts_per_group = y_counts_per_group[perm]\n+            inv_perm = np.empty_like(perm)\n+            inv_perm[perm] = np.arange(perm.size)\n+            groups_inv = inv_perm[groups_inv]\n \n         # Stable sort to keep shuffled order for groups with the same\n         # class distribution variance\ndiff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex 80ac64f8169be..3f0059be2bf4a 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -724,6 +724,37 @@ def test_stratified_group_kfold_homogeneous_groups(y, groups, expected):\n         assert_allclose(split_dist, expect_dist, atol=0.001)\n \n \n+def test_stratified_group_kfold_shuffle_preserves_stratification():\n+    # Check StratifiedGroupKFold with shuffle=True preserves stratification:\n+    # shuffling only affects tie-breaking among groups with identical\n+    # standard deviation of class distribution (see #32478)\n+    y = np.array([0] * 12 + [1] * 6)\n+    X = np.ones((len(y), 1))\n+    # Groups are arranged so perfect stratification across 3 folds is\n+    # achievable\n+    groups = np.array([1, 1, 3, 3, 3, 4, 5, 5, 5, 5, 7, 7, 2, 2, 6, 6, 8, 8])\n+    expected_class_ratios = np.asarray([2.0 / 3, 1.0 / 3])\n+\n+    # Run multiple seeds to ensure the property holds regardless of the\n+    # tie-breaking order among groups with identical std of class distribution\n+    n_iters = 100\n+    for seed in range(n_iters):\n+        sgkf = StratifiedGroupKFold(n_splits=3, shuffle=True, random_state=seed)\n+        test_sizes = []\n+        for train, test in sgkf.split(X, y, groups):\n+            # check group constraint\n+            assert np.intersect1d(groups[train], groups[test]).size == 0\n+            # check y distribution\n+            assert_allclose(\n+                np.bincount(y[train]) / len(train), expected_class_ratios, atol=1e-8\n+            )\n+            assert_allclose(\n+                np.bincount(y[test]) / len(test), expected_class_ratios, atol=1e-8\n+            )\n+            test_sizes.append(len(test))\n+        assert np.ptp(test_sizes) <= 1\n+\n+\n @pytest.mark.parametrize(\"cls_distr\", [(0.4, 0.6), (0.3, 0.7), (0.2, 0.8), (0.8, 0.2)])\n @pytest.mark.parametrize(\"n_groups\", [5, 30, 70])\n def test_stratified_group_kfold_against_group_kfold(cls_distr, n_groups):\n",
  "fail_to_pass": [
    "test_stratified_group_kfold_shuffle_preserves_stratification"
  ],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/model_selection/_split.py",
    "sklearn/model_selection/tests/test_split.py"
  ],
  "difficulty": "medium",
  "created_at": "2025-10-19T20:16:05Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/32540",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/issues/32478"
}