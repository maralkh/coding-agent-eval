{
  "id": "scikit-learn__scikit-learn-30039",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "fbb32eae585fa0a20f0a489f2eddc3608ac0391b",
  "issue_number": 30007,
  "issue_title": "Upgrade free-threading CI to run with pytest-freethreaded instead of pytest-xdist",
  "issue_body": "There is a new kid on the block that should help us find out whether scikit-learn and its dependencies can be reliably considered free-threading compatible:\n\nhttps://pypi.org/project/pytest-freethreaded/\n\nLet's try to adopt it in scikit-learn.\n\nHere is a possible plan:\n\n- first run the tests locally a few times and see if they are tests (or a set of interacting tests) that cause a crash or a failure, open an issue for each of them, possibly upstream and then mark them as skipped under free-threading builds with a reference to the issue in the \"reason\" field;\n- then upgrade our nightly free-threading scheduled CI run to use `pytest-freethreaded`.\n\nAny comments @lesteve @jeremiedbb @ngoldbaum?\n\nEDIT: anyone interested in getting hands on the first item can find this resource useful:\n\nhttps://py-free-threading.github.io/\n\nEDIT 2: there is also the [pytest-run-parallel](https://github.com/Quansight-Labs/pytest-run-parallel) plugin that can serve a similar purpose.\n\nEDIT3: here is a TODO/plan for this problem:\n\n\n\n- [x] resync and simplify #30041 to leverage https://github.com/Quansight-Labs/pytest-run-parallel/pull/19, https://github.com/Quansight-Labs/pytest-run-parallel/pull/33 and https://github.com/Quansight-Labs/pytest-run-parallel/pull/34\n- [x] configure the `[free-threading]` CI to run with `pytest-run-parallel` #32023\n- [x] enable the free-threading flag in Cython extension #31342\n  - [x] investigate and fix crashes and test failures or open tracking issues and mark tests as `thread_unsafe` ;)\n- [ ] benchmark the use of threading, in particular when we we expect nested parallelism between Python threads (e.g. in `GridSearchCV` with the \"threading\" backend of joblib) and BLAS or OpenMP native threading in the underlying estimators.\n- [ ] communicate results on a blog post / pydata presentation / social media.",
  "pr_number": 30039,
  "pr_title": "MAINT remove side-effects in test_partial_dependence",
  "gold_patch": "diff --git a/sklearn/inspection/tests/test_partial_dependence.py b/sklearn/inspection/tests/test_partial_dependence.py\nindex 9768516efa492..16c23d4d5dd4e 100644\n--- a/sklearn/inspection/tests/test_partial_dependence.py\n+++ b/sklearn/inspection/tests/test_partial_dependence.py\n@@ -268,7 +268,9 @@ def test_partial_dependence_helpers(est, method, target_feature):\n     # into account with the recursion method, for technical reasons. We set\n     # the mean to 0 to that this 'bug' doesn't have any effect.\n     y = y - y.mean()\n-    est.fit(X, y)\n+\n+    # Clone is necessary to make the test thread-safe.\n+    est = clone(est).fit(X, y)\n \n     # target feature will be set to .5 and then to 123\n     features = np.array([target_feature], dtype=np.intp)\n@@ -381,7 +383,7 @@ def test_recursion_decision_function(est, target_feature):\n     X, y = make_classification(n_classes=2, n_clusters_per_class=1, random_state=1)\n     assert np.mean(y) == 0.5  # make sure the init estimator predicts 0 anyway\n \n-    est.fit(X, y)\n+    est = clone(est).fit(X, y)\n \n     preds_1 = partial_dependence(\n         est,\n@@ -429,7 +431,7 @@ def test_partial_dependence_easy_target(est, power):\n     X = rng.normal(size=(n_samples, 5))\n     y = X[:, target_variable] ** power\n \n-    est.fit(X, y)\n+    est = clone(est).fit(X, y)\n \n     pdp = partial_dependence(\n         est, features=[target_variable], X=X, grid_resolution=1000, kind=\"average\"\n@@ -526,7 +528,7 @@ def fit(self, X, y):\n )\n def test_partial_dependence_error(estimator, params, err_msg):\n     X, y = make_classification(random_state=0)\n-    estimator.fit(X, y)\n+    estimator = clone(estimator).fit(X, y)\n \n     with pytest.raises(ValueError, match=err_msg):\n         partial_dependence(estimator, X, **params)\n@@ -538,7 +540,7 @@ def test_partial_dependence_error(estimator, params, err_msg):\n @pytest.mark.parametrize(\"features\", [-1, 10000])\n def test_partial_dependence_unknown_feature_indices(estimator, features):\n     X, y = make_classification(random_state=0)\n-    estimator.fit(X, y)\n+    estimator = clone(estimator).fit(X, y)\n \n     err_msg = \"all features must be in\"\n     with pytest.raises(ValueError, match=err_msg):\n@@ -552,7 +554,7 @@ def test_partial_dependence_unknown_feature_string(estimator):\n     pd = pytest.importorskip(\"pandas\")\n     X, y = make_classification(random_state=0)\n     df = pd.DataFrame(X)\n-    estimator.fit(df, y)\n+    estimator = clone(estimator).fit(df, y)\n \n     features = [\"random\"]\n     err_msg = \"A given column is not a column of the dataframe\"\n@@ -566,7 +568,7 @@ def test_partial_dependence_unknown_feature_string(estimator):\n def test_partial_dependence_X_list(estimator):\n     # check that array-like objects are accepted\n     X, y = make_classification(random_state=0)\n-    estimator.fit(X, y)\n+    estimator = clone(estimator).fit(X, y)\n     partial_dependence(estimator, list(X), [0], kind=\"average\")\n \n \n@@ -688,7 +690,7 @@ def test_partial_dependence_dataframe(estimator, preprocessor, features):\n     pd = pytest.importorskip(\"pandas\")\n     df = pd.DataFrame(scale(iris.data), columns=iris.feature_names)\n \n-    pipe = make_pipeline(preprocessor, estimator)\n+    pipe = make_pipeline(preprocessor, clone(estimator))\n     pipe.fit(df, iris.target)\n     pdp_pipe = partial_dependence(\n         pipe, df, features=features, grid_resolution=10, kind=\"average\"\n@@ -837,7 +839,7 @@ def test_partial_dependence_non_null_weight_idx(estimator, non_null_weight_idx):\n     preprocessor = make_column_transformer(\n         (StandardScaler(), [0, 2]), (RobustScaler(), [1, 3])\n     )\n-    pipe = make_pipeline(preprocessor, estimator).fit(X, y)\n+    pipe = make_pipeline(preprocessor, clone(estimator)).fit(X, y)\n \n     sample_weight = np.zeros_like(y)\n     sample_weight[non_null_weight_idx] = 1\n",
  "fail_to_pass": [],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/inspection/tests/test_partial_dependence.py"
  ],
  "difficulty": "easy",
  "created_at": "2024-10-09T16:40:46Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/30039",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/issues/30007"
}