{
  "id": "scikit-learn__scikit-learn-30409",
  "repo": "scikit-learn/scikit-learn",
  "base_commit": "29f6ca36665b955598b8af66d9588f3bec04348e",
  "issue_number": 30315,
  "issue_title": "\u26a0\ufe0f CI failed on Linux_Nightly.pylatest_pip_scipy_dev (last failure: Dec 05, 2024) \u26a0\ufe0f",
  "issue_body": "**CI is still failing on [Linux_Nightly.pylatest_pip_scipy_dev](https://dev.azure.com/scikit-learn/scikit-learn/_build/results?buildId=72598&view=logs&j=dfe99b15-50db-5d7b-b1e9-4105c42527cf)** (Dec 05, 2024)\n- test_partial_dependence_binary_model_grid_resolution[features0-10-10]",
  "pr_number": 30409,
  "pr_title": "FIX: deprecate integer valued numerical features for PDP",
  "gold_patch": "diff --git a/doc/whats_new/upcoming_changes/sklearn.inspection/30409.api.rst b/doc/whats_new/upcoming_changes/sklearn.inspection/30409.api.rst\nnew file mode 100644\nindex 0000000000000..cbbfe19a9b7cc\n--- /dev/null\n+++ b/doc/whats_new/upcoming_changes/sklearn.inspection/30409.api.rst\n@@ -0,0 +1,5 @@\n+- :func:`inspection.partial_dependence` does no longer accept integer dtype for\n+  numerical feature columns. Explicity conversion to floating point values is\n+  now required before calling this tool (and preferably even before fitting the\n+  model to inspect).\n+  By :user:`Olivier Grisel <ogrisel>`\ndiff --git a/sklearn/inspection/_partial_dependence.py b/sklearn/inspection/_partial_dependence.py\nindex 46cd357785357..7c777df364329 100644\n--- a/sklearn/inspection/_partial_dependence.py\n+++ b/sklearn/inspection/_partial_dependence.py\n@@ -3,6 +3,7 @@\n # Authors: The scikit-learn developers\n # SPDX-License-Identifier: BSD-3-Clause\n \n+import warnings\n from collections.abc import Iterable\n \n import numpy as np\n@@ -699,6 +700,24 @@ def partial_dependence(\n     if isinstance(features, (str, int)):\n         features = [features]\n \n+    for feature_idx, feature, is_cat in zip(features_indices, features, is_categorical):\n+        if is_cat:\n+            continue\n+\n+        if _safe_indexing(X, feature_idx, axis=1).dtype.kind in \"iu\":\n+            # TODO(1.8): raise a ValueError instead.\n+            warnings.warn(\n+                f\"The column {feature!r} contains integer data. Partial \"\n+                \"dependence plots are not supported for integer data: this \"\n+                \"can lead to implicit rounding with NumPy arrays or even errors \"\n+                \"with newer pandas versions. Please convert numerical features\"\n+                \"to floating point dtypes ahead of time to avoid problems. \"\n+                \"This will raise ValueError in scikit-learn 1.8.\",\n+                FutureWarning,\n+            )\n+            # Do not warn again for other features to avoid spamming the caller.\n+            break\n+\n     X_subset = _safe_indexing(X, features_indices, axis=1)\n \n     custom_values_for_X_subset = {\ndiff --git a/sklearn/inspection/_plot/tests/test_plot_partial_dependence.py b/sklearn/inspection/_plot/tests/test_plot_partial_dependence.py\nindex 3fa623c39b787..b2338b5c03b3a 100644\n--- a/sklearn/inspection/_plot/tests/test_plot_partial_dependence.py\n+++ b/sklearn/inspection/_plot/tests/test_plot_partial_dependence.py\n@@ -870,7 +870,7 @@ def test_plot_partial_dependence_legend(pyplot):\n     X = pd.DataFrame(\n         {\n             \"col_A\": [\"A\", \"B\", \"C\"],\n-            \"col_B\": [1, 0, 2],\n+            \"col_B\": [1.0, 0.0, 2.0],\n             \"col_C\": [\"C\", \"B\", \"A\"],\n         }\n     )\ndiff --git a/sklearn/inspection/tests/test_partial_dependence.py b/sklearn/inspection/tests/test_partial_dependence.py\nindex aff12044ee32a..25cefe8d7e24f 100644\n--- a/sklearn/inspection/tests/test_partial_dependence.py\n+++ b/sklearn/inspection/tests/test_partial_dependence.py\n@@ -2,6 +2,9 @@\n Testing for the partial dependence module.\n \"\"\"\n \n+import re\n+import warnings\n+\n import numpy as np\n import pytest\n \n@@ -751,13 +754,14 @@ def test_partial_dependence_binary_model_grid_resolution(\n     pd = pytest.importorskip(\"pandas\")\n     model = DummyClassifier()\n \n+    rng = np.random.RandomState(0)\n     X = pd.DataFrame(\n         {\n-            \"a\": np.random.randint(0, 10, size=100),\n-            \"b\": np.random.randint(0, 10, size=100),\n+            \"a\": rng.randint(0, 10, size=100).astype(np.float64),\n+            \"b\": rng.randint(0, 10, size=100).astype(np.float64),\n         }\n     )\n-    y = pd.Series(np.random.randint(0, 2, size=100))\n+    y = pd.Series(rng.randint(0, 2, size=100))\n     model.fit(X, y)\n \n     part_dep = partial_dependence(\n@@ -773,9 +777,9 @@ def test_partial_dependence_binary_model_grid_resolution(\n @pytest.mark.parametrize(\n     \"features, custom_values, n_vals_expected\",\n     [\n-        ([\"a\"], {\"a\": [1, 2, 3, 4]}, 4),\n-        ([\"a\"], {\"a\": [1, 2]}, 2),\n-        ([\"a\"], {\"a\": [1]}, 1),\n+        ([\"a\"], {\"a\": [1.0, 2.0, 3.0, 4.0]}, 4),\n+        ([\"a\"], {\"a\": [1.0, 2.0]}, 2),\n+        ([\"a\"], {\"a\": [1.0]}, 1),\n     ],\n )\n def test_partial_dependence_binary_model_custom_values(\n@@ -784,7 +788,7 @@ def test_partial_dependence_binary_model_custom_values(\n     pd = pytest.importorskip(\"pandas\")\n     model = DummyClassifier()\n \n-    X = pd.DataFrame({\"a\": [1, 2, 3, 4], \"b\": [6, 7, 8, 9]})\n+    X = pd.DataFrame({\"a\": [1.0, 2.0, 3.0, 4.0], \"b\": [6.0, 7.0, 8.0, 9.0]})\n     y = pd.Series([0, 1, 0, 1])\n     model.fit(X, y)\n \n@@ -804,7 +808,7 @@ def test_partial_dependence_binary_model_custom_values(\n     [\n         ([\"b\"], {\"b\": [\"a\", \"b\"]}, 2),\n         ([\"b\"], {\"b\": [\"a\"]}, 1),\n-        ([\"a\", \"b\"], {\"a\": [1, 2], \"b\": [\"a\", \"b\"]}, 4),\n+        ([\"a\", \"b\"], {\"a\": [1.0, 2.0], \"b\": [\"a\", \"b\"]}, 4),\n     ],\n )\n def test_partial_dependence_pipeline_custom_values(\n@@ -815,11 +819,11 @@ def test_partial_dependence_pipeline_custom_values(\n         SimpleImputer(strategy=\"most_frequent\"), OneHotEncoder(), DummyClassifier()\n     )\n \n-    X = pd.DataFrame({\"a\": [1, 2, 3, 4], \"b\": [\"a\", \"b\", \"a\", \"b\"]})\n+    X = pd.DataFrame({\"a\": [1.0, 2.0, 3.0, 4.0], \"b\": [\"a\", \"b\", \"a\", \"b\"]})\n     y = pd.Series([0, 1, 0, 1])\n     pl.fit(X, y)\n \n-    X_holdout = pd.DataFrame({\"a\": [1, 2, 3, 4], \"b\": [\"a\", \"b\", \"a\", None]})\n+    X_holdout = pd.DataFrame({\"a\": [1.0, 2.0, 3.0, 4.0], \"b\": [\"a\", \"b\", \"a\", None]})\n     part_dep = partial_dependence(\n         pl,\n         X_holdout,\n@@ -1134,3 +1138,61 @@ def test_mixed_type_categorical():\n     ).fit(X, y)\n     with pytest.raises(ValueError, match=\"The column #0 contains mixed data types\"):\n         partial_dependence(clf, X, features=[0])\n+\n+\n+def test_reject_array_with_integer_dtype():\n+    X = np.arange(8).reshape(4, 2)\n+    y = np.array([0, 1, 0, 1])\n+    clf = DummyClassifier()\n+    clf.fit(X, y)\n+    with pytest.warns(\n+        FutureWarning, match=re.escape(\"The column 0 contains integer data.\")\n+    ):\n+        partial_dependence(clf, X, features=0)\n+\n+    with pytest.warns(\n+        FutureWarning, match=re.escape(\"The column 1 contains integer data.\")\n+    ):\n+        partial_dependence(clf, X, features=[1], categorical_features=[0])\n+\n+    with pytest.warns(\n+        FutureWarning, match=re.escape(\"The column 0 contains integer data.\")\n+    ):\n+        partial_dependence(clf, X, features=[0, 1])\n+\n+    # The following should not raise as we do not compute numerical partial\n+    # dependence on integer columns.\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\"error\")\n+        partial_dependence(clf, X, features=1, categorical_features=[1])\n+\n+\n+def test_reject_pandas_with_integer_dtype():\n+    pd = pytest.importorskip(\"pandas\")\n+    X = pd.DataFrame(\n+        {\n+            \"a\": [1.0, 2.0, 3.0],\n+            \"b\": [1, 2, 3],\n+            \"c\": [1, 2, 3],\n+        }\n+    )\n+    y = np.array([0, 1, 0])\n+    clf = DummyClassifier()\n+    clf.fit(X, y)\n+\n+    with pytest.warns(\n+        FutureWarning, match=re.escape(\"The column 'c' contains integer data.\")\n+    ):\n+        partial_dependence(clf, X, features=\"c\")\n+\n+    with pytest.warns(\n+        FutureWarning, match=re.escape(\"The column 'c' contains integer data.\")\n+    ):\n+        partial_dependence(clf, X, features=[\"a\", \"c\"])\n+\n+    # The following should not raise as we do not compute numerical partial\n+    # dependence on integer columns.\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\"error\")\n+        partial_dependence(clf, X, features=[\"a\"])\n+        partial_dependence(clf, X, features=[\"c\"], categorical_features=[\"c\"])\n",
  "fail_to_pass": [
    "test_reject_array_with_integer_dtype",
    "test_reject_pandas_with_integer_dtype"
  ],
  "pass_to_pass": [],
  "relevant_files": [
    "sklearn/inspection/_partial_dependence.py",
    "sklearn/inspection/_plot/tests/test_plot_partial_dependence.py",
    "sklearn/inspection/tests/test_partial_dependence.py"
  ],
  "difficulty": "hard",
  "created_at": "2024-12-04T17:39:37Z",
  "pr_url": "https://github.com/scikit-learn/scikit-learn/pull/30409",
  "issue_url": "https://github.com/scikit-learn/scikit-learn/issues/30315"
}